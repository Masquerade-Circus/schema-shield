(()=>{var e,r,t=Object.create,a=Object.defineProperty,n=Object.getOwnPropertyDescriptor,i=Object.getOwnPropertyNames,o=Object.getPrototypeOf,l=Object.prototype.hasOwnProperty,d=(e={"node_modules/is-my-ip-valid/index.js"(e,r){var t=/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,a=/\/\d{1,3}(?=%|$)/,n=/\//,i=/%.*$/,o=/([^0-9a-f:/%])/i,l=/([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/i;r.exports.__all_regexes__=[t,a,n,i,o,l]}},function(){return r||(0,e[i(e)[0]])((r={exports:{}}).exports,r),r.exports}),s=class extends Error{name;pointer;message;value;code;constructor(e,r){super(e),this.pointer=r}};function u(e,r){if(Array.isArray(e)&&Array.isArray(r)){if(e.length!==r.length)return!1;for(let t=0;t<e.length;t++)if(!u(e[t],r[t]))return!1;return!0}if("object"==typeof e&&"object"==typeof r){if(null===e||null===r)return e===r;const t=Object.keys(e);if(t.length!==Object.keys(r).length)return!1;for(const a of t)if(!u(e[a],r[a]))return!1;return!0}return e===r}function f(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)}var m=((e,r,d)=>(d=null!=e?t(o(e)):{},((e,r,t,o)=>{if(r&&"object"==typeof r||"function"==typeof r)for(let d of i(r))l.call(e,d)||d===t||a(e,d,{get:()=>r[d],enumerable:!(o=n(r,d))||o.enumerable});return e})(!r&&e&&e.__esModule?d:a(d,"default",{value:e,enumerable:!0}),e)))(d()),c={"date-time":/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(\.\d+)?(Z|([+-])(\d{2}):(\d{2}))$/,time:/^(\d{2}):(\d{2}):(\d{2})(\.\d+)?(Z|([+-])(\d{2}):(\d{2}))$/,uri:/^[a-zA-Z][a-zA-Z0-9+\-.]*:[^\s]*$/,email:/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,hostname:/^[a-zA-Z0-9][a-zA-Z0-9-]{0,62}(\.[a-zA-Z0-9][a-zA-Z0-9-]{0,62})*[a-zA-Z0-9]$/,date:/^(\d{4})-(\d{2})-(\d{2})$/,"json-pointer":/^\/(?:[^~]|~0|~1)*$/,"relative-json-pointer":/^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/},v={"date-time"(e){const r=e.toUpperCase();if(!c["date-time"].test(r))return!1;const t=new Date(r);return!isNaN(t.getTime())},uri:e=>c.uri.test(e),email(e){if(!c.email.test(e))return!1;const[r,t]=e.split("@");return!(r.length>64||-1!==r.indexOf("..")||"."===r[0]||"."===r[r.length-1])&&!(t.length>255||-1!==t.indexOf("..")||"."===t[0]||"."===t[t.length-1])},ipv4:(0,m.default)({version:4}),ipv6:(0,m.default)({version:6}),hostname:e=>c.hostname.test(e),date:e=>"string"==typeof e&&(!1!==c.date.test(e)&&!isNaN(new Date(e).getTime())),regex(e){try{return new RegExp(e),!0}catch(e){return!1}},"json-pointer":e=>""===e||c["json-pointer"].test(e),"relative-json-pointer":e=>""===e||c["relative-json-pointer"].test(e),time:e=>c.time.test(e),duration:!1,"idn-email":!1,"idn-hostname":!1,uuid:!1,"uri-reference":!1,iri:!1,"iri-reference":!1,"uri-template":!1},p={object:(e,r,t)=>f(r)?{valid:!0,error:null,data:r}:{valid:!1,error:new s("Data is not an object",t),data:r},array(e,r,t){if(Array.isArray(r))return{valid:!0,error:null,data:r};if("object"==typeof r&&null!==r&&"length"in r){const e=Object.keys(r);return e.length>0&&("0"!==e[0]||e.length!==r.length)?{valid:!1,error:new s("Data is not an array",t),data:r}:{valid:!0,error:null,data:r}}return{valid:!1,error:new s("Data is not an array",t),data:r}},string:(e,r,t)=>"string"==typeof r?{valid:!0,error:null,data:r}:{valid:!1,error:new s("Data is not a string",t),data:r},number:(e,r,t)=>"number"==typeof r?{valid:!0,error:null,data:r}:{valid:!1,error:new s("Data is not a number",t),data:r},integer:(e,r,t)=>"number"==typeof r&&Number.isInteger(r)?{valid:!0,error:null,data:r}:{valid:!1,error:new s("Data is not an integer",t),data:r},boolean:(e,r,t)=>"boolean"==typeof r?{valid:!0,error:null,data:r}:{valid:!1,error:new s("Data is not a boolean",t),data:r},null:(e,r,t)=>null===r?{valid:!0,error:null,data:r}:{valid:!1,error:new s("Data is not null",t),data:r}},y={...{required(e,r,t){if(!f(r))return{valid:!0,error:null,data:r};for(let a=0;a<e.required.length;a++){const n=e.required[a];if(!r.hasOwnProperty(n))return{valid:!1,error:new s("Property is required",`${t}/${n}`),data:r}}return{valid:!0,error:null,data:r}},properties(e,r,t,a){if(!f(r))return{valid:!0,error:null,data:r};let n={...r};const i=Object.keys(e.properties);for(const o of i){const i=r[o];if(void 0===i){const r=e.properties[o];f(r)&&"default"in r&&(n[o]=r.default);continue}if("boolean"==typeof e.properties[o]){if(!1===e.properties[o])return{valid:!1,error:new s("Property is not allowed",`${t}/${o}`),data:r};continue}const l=a.validate(e.properties[o],i);if(n[o]=l.data,!l.valid)return{valid:!1,error:l.error,data:n}}return{valid:!0,error:null,data:n}},maxProperties:(e,r,t)=>!f(r)||Object.keys(r).length<=e.maxProperties?{valid:!0,error:null,data:r}:{valid:!1,error:new s("Object has too many properties",t),data:r},minProperties:(e,r,t)=>!f(r)||Object.keys(r).length>=e.minProperties?{valid:!0,error:null,data:r}:{valid:!1,error:new s("Object has too few properties",t),data:r},additionalProperties(e,r,t,a){if(!f(r))return{valid:!0,error:null,data:r};let n={...r};const i=Object.keys(r),o=a.isCompiledSchema(e.additionalProperties);for(const l of i)if(!e.properties||!e.properties.hasOwnProperty(l)){if(e.patternProperties){let r=!1;for(const t in e.patternProperties)if(new RegExp(t,"u").test(l)){r=!0;break}if(r)continue}if(!1===e.additionalProperties)return{valid:!1,error:new s("Property is not allowed",`${t}/${l}`),data:r};if(o){const r=a.validate(e.additionalProperties,n[l]);if(n[l]=r.data,!r.valid)return{valid:!1,error:r.error,data:n}}}return{valid:!0,error:null,data:n}},patternProperties(e,r,t,a){if(!f(r))return{valid:!0,error:null,data:r};let n={...r};const i=Object.keys(e.patternProperties);for(const r of i){const i=new RegExp(r,"u");if("boolean"==typeof e.patternProperties[r]){if(!1===e.patternProperties[r])for(const e in n)if(i.test(e))return{valid:!1,error:new s("Property is not allowed",`${t}/${e}`),data:n};continue}const o=Object.keys(n);for(const t of o)if(i.test(t)){const i=a.validate(e.patternProperties[r],n[t]);if(n[t]=i.data,!i.valid)return{valid:!1,error:i.error,data:n}}}return{valid:!0,error:null,data:n}},propertyNames(e,r,t,a){if(!f(r))return{valid:!0,error:null,data:r};if("boolean"==typeof e.propertyNames&&!1===e.propertyNames&&Object.keys(r).length>0)return{valid:!1,error:new s("Property names are not allowed",t),data:r};let n={...r};if(a.isCompiledSchema(e.propertyNames))for(let r in n){const t=a.validate(e.propertyNames,r);if(!t.valid)return{valid:!1,error:t.error,data:n}}return{valid:!0,error:null,data:n}}},...{items(e,r,t,a){if(!Array.isArray(r))return{valid:!0,error:null,data:r};const n=e.items,i=r.length;if("boolean"==typeof n)return!1===n&&i>0?{valid:!1,error:new s("Array is not allowed",t),data:r}:{valid:!0,error:null,data:r};if(Array.isArray(n)){const e=n.length,o=[...r],l=Math.min(e,i);for(let e=0;e<l;e++){if("boolean"==typeof n[e]){if(!1===n[e]&&void 0!==o[e])return{valid:!1,error:new s("Array item is not allowed",`${t}/${e}`),data:o};continue}const r=a.validate(n[e],o[e]);if(o[e]=r.data,!r.valid)return{valid:!1,error:r.error,data:o}}return{valid:!0,error:null,data:o}}if(a.isCompiledSchema(n))for(let e=0;e<i;e++){const t=a.validate(n,r[e]);if(r[e]=t.data,!t.valid)return{valid:!1,error:t.error,data:r}}return{valid:!0,error:null,data:r}},minItems:(e,r,t)=>!Array.isArray(r)||r.length>=e.minItems?{valid:!0,error:null,data:r}:{valid:!1,error:new s("Array is too short",t),data:r},maxItems:(e,r,t)=>!Array.isArray(r)||r.length<=e.maxItems?{valid:!0,error:null,data:r}:{valid:!1,error:new s("Array is too long",t),data:r},additionalItems(e,r,t,a){if(!Array.isArray(r)||!e.items||!Array.isArray(e.items))return{valid:!0,error:null,data:r};if(!1===e.additionalItems)return r.length>e.items.length?{valid:!1,error:new s("Array has too many items",t),data:r}:{valid:!0,error:null,data:r};if(a.isCompiledSchema(e.additionalItems)){const t=[...r];for(let r=e.items.length;r<t.length;r++){const n=a.validate(e.additionalItems,t[r]);if(!n.valid)return{valid:!1,error:n.error,data:t};t[r]=n.data}return{valid:!0,error:null,data:t}}return{valid:!0,error:null,data:r}},uniqueItems(e,r,t){if(!Array.isArray(r)||!e.uniqueItems)return{valid:!0,error:null,data:r};const a=new Set;for(const e of r){let n;if(n="string"==typeof e?`s:${e}`:f(e)?`o:${JSON.stringify(Object.fromEntries(Object.entries(e).sort(([e],[r])=>e.localeCompare(r))))}`:JSON.stringify(e),a.has(n))return{valid:!1,error:new s("Array items are not unique",t),data:r};a.add(n)}return{valid:!0,error:null,data:r}}},...{minLength:(e,r,t)=>"string"!=typeof r||r.length>=e.minLength?{valid:!0,error:null,data:r}:{valid:!1,error:new s("String is too short",t),data:r},maxLength:(e,r,t)=>"string"!=typeof r||r.length<=e.maxLength?{valid:!0,error:null,data:r}:{valid:!1,error:new s("String is too long",t),data:r},pattern(e,r,t){if("string"!=typeof r)return{valid:!0,error:null,data:r};const a=new RegExp(e.pattern,"u");if(a instanceof RegExp==!1)return{valid:!1,error:new s("Pattern is not a valid regular expression",t),data:r};const n=a.test(r);return{valid:n,error:n?null:new s("String does not match pattern",t),data:r}},format(e,r,t,a){if("string"!=typeof r)return{valid:!0,error:null,data:r};const n=a.formats.get(e.format);if(!1===n)return{valid:!0,error:null,data:r};if("function"==typeof n){const a=n(r);return{valid:a,error:a?null:new s(`String does not match format ${e.format}`,t),data:r}}return{valid:!1,error:new s(`Unknown format ${e.format}`,t),data:r}},enum(e,r,t){const a=Array.isArray(r),n="object"==typeof r&&null!==r;for(let t=0;t<e.enum.length;t++){const i=e.enum[t];if(i===r)return{valid:!0,error:null,data:r};if((a&&Array.isArray(i)||n&&"object"==typeof i&&null!==i)&&u(i,r))return{valid:!0,error:null,data:r}}return{valid:!1,error:new s(`Value must be one of ${e.enum.join(", ")}`,t),data:r}}},...{minimum(e,r,t,a){if("number"!=typeof r)return{valid:!0,error:null,data:r};let n=e.minimum;"number"==typeof e.exclusiveMinimum?n=e.exclusiveMinimum+1e-15:!0===e.exclusiveMinimum&&(n+=1e-15);const i=r>=n;return{valid:i,error:i?null:new s("Number is too small",t),data:r}},maximum(e,r,t,a){if("number"!=typeof r)return{valid:!0,error:null,data:r};let n=e.maximum;"number"==typeof e.exclusiveMaximum?n=e.exclusiveMaximum-1e-15:!0===e.exclusiveMaximum&&(n-=1e-15);const i=r<=n;return{valid:i,error:i?null:new s("Number is too big",t),data:r}},multipleOf(e,r,t){if("number"!=typeof r)return{valid:!0,error:null,data:r};const a=r/e.multipleOf;if(!isFinite(a))return{valid:!0,error:null,data:r};const n=function(e,r,t=1e-15){return Math.abs(e-r)<=t*Math.max(Math.abs(e),Math.abs(r))}(a,Math.round(a));return{valid:n,error:n?null:new s("Number is not a multiple of",t),data:r}},exclusiveMinimum(e,r,t){if("number"!=typeof r||"number"!=typeof e.exclusiveMinimum||"minimum"in e)return{valid:!0,error:null,data:r};const a=r>e.exclusiveMinimum+1e-15;return{valid:a,error:a?null:new s("Number is too small",t),data:r}},exclusiveMaximum(e,r,t){if("number"!=typeof r||"number"!=typeof e.exclusiveMaximum||"maximum"in e)return{valid:!0,error:null,data:r};const a=r<e.exclusiveMaximum-1e-15;return{valid:a,error:a?null:new s("Number is too big",t),data:r}}},...{nullable:(e,r,t)=>e.nullable&&null!==r?{valid:!1,error:new s("Value must be null to be empty",t),data:r}:{valid:!0,error:null,data:r},allOf(e,r,t,a){let n=r;for(let i=0;i<e.allOf.length;i++)if(f(e.allOf[i])){const r=a.validate(e.allOf[i],n);if(!r.valid)return{valid:!1,error:r.error,data:n};n=r.data}else{if("boolean"==typeof e.allOf[i]){if(Boolean(r)!==e.allOf[i])return{valid:!1,error:new s("Value must match all schemas in allOf",t),data:n};continue}if(r!==e.allOf[i])return{valid:!1,error:new s("Value must match all schemas in allOf",t),data:n}}return{valid:!0,error:null,data:n}},anyOf(e,r,t,a){let n=r;for(let t=0;t<e.anyOf.length;t++)if(f(e.anyOf[t])){const r=a.validate(e.anyOf[t],n);if(n=r.data,r.valid)return{valid:!0,error:null,data:n}}else{if("boolean"==typeof e.anyOf[t]&&Boolean(r)===e.anyOf[t])return{valid:!0,error:null,data:n};if(r===e.anyOf[t])return{valid:!0,error:null,data:n}}return{valid:!1,error:new s("Value must match at least one schema in anyOf",t),data:r}},oneOf(e,r,t,a){let n=0,i=r;for(let t=0;t<e.oneOf.length;t++)if(f(e.oneOf[t])){const r=a.validate(e.oneOf[t],i);r.valid&&n++,i=r.data}else{if("boolean"==typeof e.oneOf[t]){Boolean(r)===e.oneOf[t]&&n++;continue}r===e.oneOf[t]&&n++}return 1===n?{valid:!0,error:null,data:i}:{valid:!1,error:new s("Value must match exactly one schema in oneOf",t),data:i}},dependencies(e,r,t,a){if(!f(r))return{valid:!0,error:null,data:r};let n=r;for(const i in e.dependencies){if(i in r==!1)continue;const o=e.dependencies[i];if(Array.isArray(o)){for(let e=0;e<o.length;e++)if(!(o[e]in r))return{valid:!1,error:new s(`Dependency ${o[e]} is missing`,t),data:n};continue}if("boolean"==typeof o){if(o)continue;return{valid:!1,error:new s(`Dependency ${i} is missing`,t),data:n}}if("string"==typeof o){if(o in r)continue;return{valid:!1,error:new s(`Dependency ${o} is missing`,t),data:n}}const l=a.validate(o,n);if(!l.valid)return{valid:!1,error:l.error,data:n};n=l.data}return{valid:!0,error:null,data:n}},const:(e,r,t)=>r===e.const||f(r)&&f(e.const)&&u(r,e.const)||Array.isArray(r)&&Array.isArray(e.const)&&u(r,e.const)?{valid:!0,error:null,data:r}:{valid:!1,error:new s("Value must be equal to const",t),data:r},contains(e,r,t,a){if(!Array.isArray(r))return{valid:!0,error:null,data:r};if("boolean"==typeof e.contains){if(e.contains){const e=r.length>0;return{valid:e,error:e?null:new s("Value must contain at least one item",t),data:r}}return{valid:!1,error:new s("Value must not contain any items",t),data:r}}for(let t=0;t<r.length;t++){if(a.validate(e.contains,r[t]).valid)return{valid:!0,error:null,data:r}}return{valid:!1,error:new s("Value must contain at least one item that matches the contains schema",t),data:r}},if(e,r,t,a){if("then"in e==!1&&"else"in e==!1)return{valid:!0,error:null,data:r};if("boolean"==typeof e.if){if(e.if){if(e.then){const t=a.validate(e.then,r);if(!t.valid)return t}}else if(e.else){const t=a.validate(e.else,r);if(!t.valid)return t}return{valid:!0,error:null,data:r}}if(a.validate(e.if,r).valid){if(e.then){const t=a.validate(e.then,r);if(!t.valid)return t}}else if(e.else){const t=a.validate(e.else,r);if(!t.valid)return t}return{valid:!0,error:null,data:r}},not(e,r,t,a){if("boolean"==typeof e.not)return e.not?{valid:!1,error:new s("Value must not be valid",t),data:r}:{valid:!0,error:null,data:r};return a.validate(e.not,r).valid?{valid:!1,error:new s("Value must not be valid",t),data:r}:{valid:!0,error:null,data:r}}}},h={SchemaShield:class{types=new Map;formats=new Map;keywords=new Map;constructor(){for(const e of Object.keys(p))this.addType(e,p[e]);for(const e of Object.keys(y))this.addKeyword(e,y[e]);for(const e of Object.keys(v))v[e]&&this.addFormat(e,v[e])}addType(e,r){this.types.set(e,r)}addFormat(e,r){this.formats.set(e,r)}addKeyword(e,r){this.keywords.set(e,r)}compile(e){const r=this.compileSchema(e,"#"),t=e=>this.validate(r,e);return t.compiledSchema=r,t}compileSchema(e,r){f(e)||(e=!0===e?{anyOf:[{type:"string"},{type:"number"},{type:"boolean"},{type:"array"},{type:"object"},{type:"null"}]}:!1===e?{oneOf:[]}:{oneOf:[e]});const t={};if("type"in e){const r=Array.isArray(e.type)?e.type:e.type.split(",").map(e=>e.trim());t.types=r.map(e=>this.types.get(e)).filter(e=>Boolean(e))}for(let a in e){if("type"===a)continue;let n=this.keywords.get(a);n&&(t.validators=t.validators||[],t.validators.push(n)),this.isSchemaLike(e[a])?t[a]=this.compileSchema(e[a],`${r}/${a}`):Array.isArray(e[a])?t[a]=e[a].map((e,t)=>this.isSchemaLike(e)?this.compileSchema(e,`${r}/${a}/${t}`):e):f(e[a])?t[a]=this.compileSchema(e[a],`${r}/${a}`):t[a]=e[a]}return t}validate(e,r){if(e.types){let t=!1;for(let a of e.types){if(a(e,r,e.pointer,this).valid){t=!0;break}}if(!t)return{valid:!1,error:new s("Invalid type",e.pointer),data:r}}if(e.validators)for(let t of e.validators){const a=t(e,r,e.pointer,this);if(!a.valid)return a}return{valid:!0,error:null,data:r}}isSchemaOrKeywordPresent(e){if("type"in e)return!0;for(let r in e)if(this.keywords.has(r))return!0;return!1}isSchemaLike(e){return f(e)&&this.isSchemaOrKeywordPresent(e)}isCompiledSchema(e){return f(e)&&("validators"in e||"types"in e)}}};"undefined"!=typeof module?module.exports=h:self.SchemaShield=h})();//# sourceMappingURL=index.min.js.map