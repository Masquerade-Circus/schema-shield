(()=>{var e,r,t=Object.create,a=Object.defineProperty,i=Object.getOwnPropertyDescriptor,o=Object.getOwnPropertyNames,n=Object.getPrototypeOf,s=Object.prototype.hasOwnProperty,l=(e={"node_modules/is-my-ip-valid/index.js"(e,r){var t=/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,a=/\/\d{1,3}(?=%|$)/,i=/\//,o=/%.*$/,n=/([^0-9a-f:/%])/i,s=/([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/i;r.exports.__all_regexes__=[t,a,i,o,n,s]}},function(){return r||(0,e[o(e)[0]])((r={exports:{}}).exports,r),r.exports}),d=class extends Error{name;pointer;message;value;code;constructor(e,r={pointer:"",value:null,code:""}){super(e),this.name="ValidationError",this.pointer=r.pointer,this.message=e,this.value=r.value,this.code=r.code}};function u(e,r){if(Array.isArray(e)&&Array.isArray(r)){if(e.length!==r.length)return!1;for(let t=0;t<e.length;t++)if(!u(e[t],r[t]))return!1;return!0}if("object"==typeof e&&"object"==typeof r){if(null===e||null===r)return e===r;const t=Object.keys(e);if(t.length!==Object.keys(r).length)return!1;for(const a of t)if(!u(e[a],r[a]))return!1;return!0}return e===r}function p(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)}var f=((e,r,l)=>(l=null!=e?t(n(e)):{},((e,r,t,n)=>{if(r&&"object"==typeof r||"function"==typeof r)for(let l of o(r))s.call(e,l)||l===t||a(e,l,{get:()=>r[l],enumerable:!(n=i(r,l))||n.enumerable});return e})(!r&&e&&e.__esModule?l:a(l,"default",{value:e,enumerable:!0}),e)))(l()),c={"date-time":/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(\.\d+)?(Z|([+-])(\d{2}):(\d{2}))$/,uri:/^[a-zA-Z][a-zA-Z0-9+\-.]*:[^\s]*$/,email:/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,hostname:/^[a-zA-Z0-9][a-zA-Z0-9-]{0,62}(\.[a-zA-Z0-9][a-zA-Z0-9-]{0,62})*[a-zA-Z0-9]$/,date:/^(\d{4})-(\d{2})-(\d{2})$/,"json-pointer":/^\/(?:[^~]|~0|~1)*$/,"relative-json-pointer":/^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/};function v(e){throw new d(`Format "${e}" is not implemented yet. Please open an issue on GitHub.`)}var m={"date-time"(e){const r=e.toUpperCase();if(!1===c["date-time"].test(r))return!1;const t=new Date(r);return!isNaN(t.getTime())},uri:e=>c.uri.test(e),email(e){if(!1===c.email.test(e))return!1;const[r,t]=e.split("@");return!(r.length>64||-1!==r.indexOf("..")||"."===r[0]||"."===r[r.length-1])&&!(t.length>255||-1!==t.indexOf("..")||"."===t[0]||"."===t[t.length-1])},ipv4:(0,f.default)({version:4}),ipv6:(0,f.default)({version:6}),hostname:e=>c.hostname.test(e),date:e=>"string"==typeof e&&(!1!==c.date.test(e)&&!isNaN(new Date(e).getTime())),regex(e){try{return new RegExp(e),!0}catch(e){return!1}},"json-pointer":e=>""===e||c["json-pointer"].test(e),"relative-json-pointer":e=>""===e||c["relative-json-pointer"].test(e),time:e=>m["date-time"](`1970-01-01T${e}Z`.replace(/ZZ$/,"Z")),duration:v,"idn-email":v,"idn-hostname":v,uuid:v,"uri-reference":v,iri:v,"iri-reference":v,"uri-template":v},y={object:(e,r,t)=>p(r)?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Data is not an object",{pointer:t,value:r,code:"NOT_AN_OBJECT"})],data:r},array(e,r,t){if(Array.isArray(r))return{valid:!0,errors:[],data:r};if("object"==typeof r&&null!==r&&"length"in r){const e=Object.keys(r);return e.length>0&&("0"!==e[0]||e.length!==r.length)?{valid:!1,errors:[new d("Data is not an array",{pointer:t,value:r,code:"NOT_AN_ARRAY"})],data:r}:{valid:!0,errors:[],data:r}}return{valid:!1,errors:[new d("Data is not an array",{pointer:t,value:r,code:"NOT_AN_ARRAY"})],data:r}},string:(e,r,t)=>"string"==typeof r?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Data is not a string",{pointer:t,value:r,code:"NOT_A_STRING"})],data:r},number:(e,r,t)=>"number"==typeof r?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Data is not a number",{pointer:t,value:r,code:"NOT_A_NUMBER"})],data:r},integer:(e,r,t)=>"number"==typeof r&&Number.isInteger(r)?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Data is not an integer",{pointer:t,value:r,code:"NOT_AN_INTEGER"})],data:r},boolean:(e,r,t)=>"boolean"==typeof r?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Data is not a boolean",{pointer:t,value:r,code:"NOT_A_BOOLEAN"})],data:r},null:(e,r,t)=>null===r?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Data is not null",{pointer:t,value:r,code:"NOT_NULL"})],data:r}},h={minimum(e,r,t,a){if("number"!=typeof r)return{valid:!0,errors:[],data:r};if("number"==typeof e.exclusiveMinimum)return h.exclusiveMinimum(e,r,t,a);let i=e.minimum;"boolean"==typeof e.exclusiveMinimum&&!0===e.exclusiveMinimum&&(i+=1e-15);const o=r>=i;return{valid:o,errors:o?[]:[new d("Number is too small",{pointer:t,value:r,code:"NUMBER_TOO_SMALL"})],data:r}},maximum(e,r,t,a){if("number"!=typeof r)return{valid:!0,errors:[],data:r};if("number"==typeof e.exclusiveMaximum)return h.exclusiveMaximum(e,r,t,a);let i=e.maximum;"boolean"==typeof e.exclusiveMaximum&&!0===e.exclusiveMaximum&&(i-=1e-15);const o=r<=i;return{valid:o,errors:o?[]:[new d("Number is too big",{pointer:t,value:r,code:"NUMBER_TOO_BIG"})],data:r}},multipleOf(e,r,t){if("number"!=typeof r)return{valid:!0,errors:[],data:r};const a=r/e.multipleOf;if(!isFinite(a))return{valid:!0,errors:[],data:r};const i=function(e,r,t=1e-15){return Math.abs(e-r)<=t*Math.max(Math.abs(e),Math.abs(r))}(a,Math.round(a));return{valid:i,errors:i?[]:[new d("Number is not a multiple of",{pointer:t,value:r,code:"NUMBER_NOT_MULTIPLE_OF"})],data:r}},exclusiveMinimum(e,r,t){if("number"!=typeof r)return{valid:!0,errors:[],data:r};if("number"!=typeof e.exclusiveMinimum)return{valid:!0,errors:[],data:r};const a=r>e.exclusiveMinimum+1e-15;return{valid:a,errors:a?[]:[new d("Number is too small",{pointer:t,value:r,code:"NUMBER_TOO_SMALL"})],data:r}},exclusiveMaximum(e,r,t){if("number"!=typeof r)return{valid:!0,errors:[],data:r};if("number"!=typeof e.exclusiveMaximum)return{valid:!0,errors:[],data:r};const a=r<e.exclusiveMaximum-1e-15;return{valid:a,errors:a?[]:[new d("Number is too big",{pointer:t,value:r,code:"NUMBER_TOO_BIG"})],data:r}}},O={nullable:(e,r,t)=>e.nullable&&null!==r?{valid:!1,errors:[new d("Value must be null to be empty",{pointer:t,value:r,code:"VALUE_NOT_NULL"})],data:r}:{valid:!0,errors:[],data:r},allOf(e,r,t,a){const i=[];let o=r;for(let n=0;n<e.allOf.length;n++)if(p(e.allOf[n])){const{validator:r}=e.allOf[n];if(!r)continue;const s=r(e.allOf[n],o,t,a);s.valid||i.push(...s.errors),o=s.data}else{if("boolean"==typeof e.allOf[n]){Boolean(r)!==e.allOf[n]&&i.push(new d("Value must match all schemas in allOf",{pointer:t,value:r,code:"VALUE_DOES_NOT_MATCH_ALL_OF"}));continue}r!==e.allOf[n]&&i.push(new d("Value must match all schemas in allOf",{pointer:t,value:r,code:"VALUE_DOES_NOT_MATCH_ALL_OF"}))}return{valid:0===i.length,errors:i,data:o}},anyOf(e,r,t,a){let i=r;for(let o=0;o<e.anyOf.length;o++)if(p(e.anyOf[o])){const{validator:n}=e.anyOf[o];if(!n)return{valid:!0,errors:[],data:r};const s=n(e.anyOf[o],i,t,a);if(i=s.data,s.valid)return{valid:!0,errors:[],data:i}}else{if("boolean"==typeof e.anyOf[o]&&Boolean(r)===e.anyOf[o])return{valid:!0,errors:[],data:i};if(r===e.anyOf[o])return{valid:!0,errors:[],data:i}}return{valid:!1,errors:[new d("Value must match at least one schema in anyOf",{pointer:t,value:r,code:"VALUE_DOES_NOT_MATCH_ANY_OF"})],data:r}},oneOf(e,r,t,a){const i=[];let o=0,n=r;for(let s=0;s<e.oneOf.length;s++)if(p(e.oneOf[s])){const{validator:r}=e.oneOf[s];if(!r){o++;continue}const l=r(e.oneOf[s],n,t,a);l.valid?o++:i.push(...l.errors),n=l.data}else{if("boolean"==typeof e.oneOf[s]){Boolean(r)===e.oneOf[s]&&o++;continue}r===e.oneOf[s]&&o++}return 1===o?{valid:!0,errors:[],data:n}:{valid:!1,errors:[new d("Value must match exactly one schema in oneOf",{pointer:t,value:r,code:"VALUE_DOES_NOT_MATCH_ONE_OF"})],data:n}},dependencies(e,r,t,a){if(!p(r))return{valid:!0,errors:[],data:r};const i=[];let o=r;for(const n in e.dependencies){if(n in r==!1)continue;const s=e.dependencies[n];if(Array.isArray(s)){for(let e=0;e<s.length;e++)s[e]in r||i.push(new d(`Dependency ${s[e]} is missing`,{pointer:t,value:r,code:"DEPENDENCY_MISSING"}));continue}if("boolean"==typeof s){if(s)continue;i.push(new d(`Dependency ${n} is missing`,{pointer:t,value:r,code:"DEPENDENCY_MISSING"}));continue}if("string"==typeof s){if(s in r)continue;i.push(new d(`Dependency ${s} is missing`,{pointer:t,value:r,code:"DEPENDENCY_MISSING"}));continue}const{validator:l}=s;if(!l)continue;const u=l(s,o,t,a);u.valid||i.push(...u.errors),o=u.data}return{valid:0===i.length,errors:i,data:o}},const:(e,r,t)=>r===e.const||p(r)&&p(e.const)&&u(r,e.const)||Array.isArray(r)&&Array.isArray(e.const)&&u(r,e.const)?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Value must be equal to const",{pointer:t,value:r,code:"VALUE_NOT_EQUAL_TO_CONST"})],data:r},contains(e,r,t,a){if(!Array.isArray(r))return{valid:!0,errors:[],data:r};if("boolean"==typeof e.contains){if(e.contains){const e=r.length>0;return{valid:e,errors:e?[]:[new d("Value must contain at least one item",{pointer:t,value:r,code:"VALUE_DOES_NOT_CONTAIN_ITEM"})],data:r}}return{valid:!1,errors:[new d("Value must not contain any items",{pointer:t,value:r,code:"VALUE_CONTAINS_ITEM"})],data:r}}const{validator:i}=e.contains;if(!i)return{valid:!0,errors:[],data:r};for(let o=0;o<r.length;o++){if(i(e.contains,r[o],`${t}/${o}`,a).valid)return{valid:!0,errors:[],data:r}}return{valid:!1,errors:[new d("Value must contain at least one item that matches the contains schema",{pointer:t,value:r,code:"VALUE_DOES_NOT_CONTAIN_MATCHING_ITEM"})],data:r}},if(e,r,t,a){if("then"in e==!1&&"else"in e==!1)return{valid:!0,errors:[],data:r};if("boolean"==typeof e.if){if(e.if){if(e.then){const{validator:i}=e.then;if(i){const o=i(e.then,r,t,a);if(!o.valid)return o}}}else if(e.else){const{validator:i}=e.else;if(i){const o=i(e.else,r,t,a);if(!o.valid)return o}}return{valid:!0,errors:[],data:r}}const{validator:i}=e.if;if(!i)return{valid:!0,errors:[],data:r};if(i(e.if,r,t,a).valid){if(e.then){const{validator:i}=e.then;if(i){const o=i(e.then,r,t,a);if(!o.valid)return o}}}else if(e.else){const{validator:i}=e.else;if(i){const o=i(e.else,r,t,a);if(!o.valid)return o}}return{valid:!0,errors:[],data:r}},not(e,r,t,a){if("boolean"==typeof e.not)return e.not?{valid:!1,errors:[new d("Value must not be valid",{pointer:t,value:r,code:"VALUE_IS_VALID"})],data:r}:{valid:!0,errors:[],data:r};const{validator:i}=e.not;if(!i)return{valid:!1,errors:[new d("Value must not be valid",{pointer:t,value:r,code:"VALUE_IS_VALID"})],data:r};return i(e.not,r,t,a).valid?{valid:!1,errors:[new d("Value must not be valid",{pointer:t,value:r,code:"VALUE_IS_VALID"})],data:r}:{valid:!0,errors:[],data:r}}},A={...{required(e,r,t){if(!p(r))return{valid:!0,errors:[],data:r};const a=[];for(let i=0;i<e.required.length;i++){const o=e.required[i];r.hasOwnProperty(o)||a.push(new d("Missing required property",{pointer:`${t}/${o}`,value:r,code:"MISSING_REQUIRED_PROPERTY"}))}return{valid:0===a.length,errors:a,data:r}},properties(e,r,t,a){if(!p(r))return{valid:!0,errors:[],data:r};const i=[];let o={...r};for(let n in e.properties){if(!r.hasOwnProperty(n)||void 0===r[n]){p(e.properties[n])&&"default"in e.properties[n]&&(o[n]=e.properties[n].default);continue}if("boolean"==typeof e.properties[n]){!1===e.properties[n]&&i.push(new d("Property is not allowed",{pointer:`${t}/${n}`,value:r[n],code:"PROPERTY_NOT_ALLOWED"}));continue}const{validator:s}=e.properties[n];if(!s)continue;const l=s(e.properties[n],o[n],`${t}/${n}`,a);o[n]=l.data,l.valid||i.push(...l.errors)}return{valid:0===i.length,errors:i,data:o}},maxProperties:(e,r,t)=>!p(r)||Object.keys(r).length<=e.maxProperties?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Object has too many properties",{pointer:t,value:r,code:"OBJECT_TOO_MANY_PROPERTIES"})],data:r},minProperties:(e,r,t)=>!p(r)||Object.keys(r).length>=e.minProperties?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Object has too few properties",{pointer:t,value:r,code:"OBJECT_TOO_FEW_PROPERTIES"})],data:r},additionalProperties(e,r,t,a){if(!p(r))return{valid:!0,errors:[],data:r};const i=[];let o={...r};for(let n in r){if(e.properties&&e.properties.hasOwnProperty(n))continue;if(e.patternProperties){let r=!1;for(let t in e.patternProperties)if(new RegExp(t,"u").test(n)){r=!0;break}if(r)continue}if(!1===e.additionalProperties){i.push(new d("Additional property not allowed",{pointer:`${t}/${n}`,value:r,code:"ADDITIONAL_PROPERTY_NOT_ALLOWED"}));continue}const{validator:s}=e.additionalProperties;if(!s)continue;const l=s(e.additionalProperties,o[n],`${t}/${n}`,a);o[n]=l.data,l.valid||i.push(...l.errors)}return{valid:0===i.length,errors:i,data:o}},patternProperties(e,r,t,a){if(!p(r))return{valid:!0,errors:[],data:r};const i=[];let o={...r};for(let n in e.patternProperties){if("boolean"==typeof e.patternProperties[n]){if(!1===e.patternProperties[n])for(let e in o)new RegExp(n,"u").test(e)&&i.push(new d("Property is not allowed",{pointer:`${t}/${e}`,value:r[e],code:"PROPERTY_NOT_ALLOWED"}));continue}const{validator:s}=e.patternProperties[n];if(s)for(let r in o)if(new RegExp(n,"u").test(r)){const l=s(e.patternProperties[n],o[r],`${t}/${r}`,a);o[r]=l.data,l.valid||i.push(...l.errors)}}return{valid:0===i.length,errors:i,data:o}},propertyNames(e,r,t,a){if(!p(r))return{valid:!0,errors:[],data:r};if("boolean"==typeof e.propertyNames&&!1===e.propertyNames&&Object.keys(r).length>0)return{valid:!1,errors:[new d("Property names are not allowed",{pointer:t,value:r,code:"PROPERTY_NAMES_NOT_ALLOWED"})],data:r};const i=[];let o={...r};const{validator:n}=e.propertyNames;if(!n)return{valid:!0,errors:[],data:r};for(let r in o){const o=n(e.propertyNames,r,t,a);o.valid||i.push(...o.errors)}return{valid:0===i.length,errors:i,data:o}}},...{items(e,r,t,a){if(!Array.isArray(r))return{valid:!0,errors:[],data:r};const i=[];let o=[...r];if(Array.isArray(e.items))for(let n=0;n<e.items.length;n++){if("boolean"==typeof e.items[n]){!1===e.items[n]&&void 0!==r[n]&&i.push(new d("Array item is not allowed",{pointer:`${t}/${n}`,value:r[n],code:"ARRAY_ITEM_NOT_ALLOWED"}));continue}const{validator:s}=e.items[n];if(!s)continue;const l=s(e.items[n],o[n],`${t}/${n}`,a);o[n]=l.data,l.valid||i.push(...l.errors)}else if("boolean"==typeof e.items)!1===e.items&&r.length>0&&i.push(new d("Array is not allowed",{pointer:t,value:r,code:"ARRAY_NOT_ALLOWED"}));else{const{validator:n}=e.items;if(!n)return{valid:!0,errors:[],data:r};for(let r=0;r<o.length;r++){const s=n(e.items,o[r],`${t}/${r}`,a);o[r]=s.data,s.valid||i.push(...s.errors)}}return{valid:0===i.length,errors:i,data:o}},minItems:(e,r,t)=>!Array.isArray(r)||r.length>=e.minItems?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Array is too short",{pointer:t,value:r,code:"ARRAY_TOO_SHORT"})],data:r},maxItems:(e,r,t)=>!Array.isArray(r)||r.length<=e.maxItems?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Array is too long",{pointer:t,value:r,code:"ARRAY_TOO_LONG"})],data:r},additionalItems(e,r,t,a){if(!Array.isArray(r)||!e.items||!Array.isArray(e.items))return{valid:!0,errors:[],data:r};if(!1===e.additionalItems)return r.length>e.items.length?{valid:!1,errors:[new d("Array has too many items",{pointer:t,value:r,code:"ARRAY_TOO_MANY_ITEMS"})],data:r}:{valid:!0,errors:[],data:r};const i=[];let o=[...r];if("object"==typeof e.additionalItems)for(let r=e.items.length;r<o.length;r++){const{validator:n}=e.additionalItems,s=n(e.additionalItems,o[r],`${t}/${r}`,a);s.valid||i.push(...s.errors),o[r]=s.data}return{valid:0===i.length,errors:i,data:o}},uniqueItems(e,r,t){if(!Array.isArray(r)||!e.uniqueItems)return{valid:!0,errors:[],data:r};const a=new Set;for(const e of r){let i=e;if("string"==typeof e)i=`"${e}"`;else if(p(e)){const r=Object.keys(e).sort(),t={};for(let a=0;a<r.length;a++)t[r[a]]=e[r[a]];i=JSON.stringify(t)}else Array.isArray(e)&&(i=JSON.stringify(e));if(a.has(i))return{valid:!1,errors:[new d("Array items are not unique",{pointer:t,value:r,code:"ARRAY_ITEMS_NOT_UNIQUE"})],data:r};a.add(i)}return{valid:!0,errors:[],data:r}}},...{minLength:(e,r,t)=>"string"!=typeof r||r.length>=e.minLength?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("String is too short",{pointer:t,value:r,code:"STRING_TOO_SHORT"})],data:r},maxLength:(e,r,t)=>"string"!=typeof r||r.length<=e.maxLength?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("String is too long",{pointer:t,value:r,code:"STRING_TOO_LONG"})],data:r},pattern(e,r,t){if("string"!=typeof r)return{valid:!0,errors:[],data:r};const a=new RegExp(e.pattern,"u");if(a instanceof RegExp==!1)return{valid:!1,errors:[new d("Pattern is not a valid regular expression",{pointer:t,value:r,code:"PATTERN_IS_NOT_REGEXP"})],data:r};const i=a.test(r);return{valid:i,errors:i?[]:[new d("String does not match pattern",{pointer:t,value:r,code:"STRING_DOES_NOT_MATCH_PATTERN"})],data:r}},format(e,r,t,a){if("string"!=typeof r)return{valid:!0,errors:[],data:r};const i=a.formats.get(e.format);if(!i)return{valid:!1,errors:[new d(`Unknown format ${e.format}`,{pointer:t,value:r,code:"UNKNOWN_FORMAT"})],data:r};const o=i(r);return{valid:o,errors:o?[]:[new d(`String does not match format ${e.format}`,{pointer:t,value:r,code:"STRING_DOES_NOT_MATCH_FORMAT"})],data:r}},enum(e,r,t){for(let t=0;t<e.enum.length;t++)if(e.enum[t]===r)return{valid:!0,errors:[],data:r};if(Array.isArray(r))for(let t=0;t<e.enum.length;t++)if(Array.isArray(e.enum[t])&&u(e.enum[t],r))return{valid:!0,errors:[],data:r};if("object"==typeof r&&null!==r)for(let t=0;t<e.enum.length;t++)if("object"==typeof e.enum[t]&&null!==e.enum[t]&&u(e.enum[t],r))return{valid:!0,errors:[],data:r};return{valid:!1,errors:[new d(`Value must be one of ${e.enum.join(", ")}`,{pointer:t,value:r,code:"VALUE_NOT_IN_ENUM"})],data:r}}},...h,...O},_={SchemaShield:class{types=new Map;formats=new Map;keywords=new Map;constructor(){for(const e in y)this.addType(e,y[e]);for(const e in A)this.addKeyword(e,A[e]);for(const e in m)this.addFormat(e,m[e])}addType(e,r){this.types.set(e,r)}addFormat(e,r){this.formats.set(e,r)}addKeyword(e,r){this.keywords.set(e,r)}compile(e){const r=this.compileSchema(e,"#"),t=e=>r.validator(r,e,"#",this);return t.compiledSchema=r,t}compileSchema(e,r){this.isSchemaLike(e)||(!0===e&&(e={anyOf:[{type:"string"},{type:"number"},{type:"boolean"},{type:"array"},{type:"object"},{type:"null"}]}),!1===e&&(e={oneOf:[]}));const t={...e,pointer:r};if("type"in t){const e=Array.isArray(t.type)?t.type:t.type.split(",").map(e=>e.trim());t.validators=e.filter(e=>this.types.has(e)).map(e=>this.types.get(e))}t.validator=(e,r,t)=>{if(void 0===r&&"#"===t)return{valid:!1,errors:[new d("Data is undefined",{pointer:t,value:r,code:"DATA_UNDEFINED"})],data:r};let a=r;const i=this.validateTypes(e,a,t);return!1===i.valid?i:(a=i.data,this.validateKeywords(e,a,t))};for(let a in e)if("type"!==a){if(this.keywords.has(a)){const e=this.keywords.get(a);t.keywords=t.keywords||{},t.keywords[a]=e}this.handleSubSchema(a,e,r,t)}return t}handleSubSchema(e,r,t,a){if(Array.isArray(r[e]))a[e]=r[e].map((r,a)=>this.isSchemaLike(r)?this.compileSchema(r,`${t}/${e}/${a}`):r);else if(p(r[e])){if(this.isSchemaLike(r[e])&&"properties"!==e)return void(a[e]=this.compileSchema(r[e],`${t}/${e}`));for(let i in r[e])this.isSchemaLike(r[e][i])&&(a[e]=a[e]||{},a[e][i]=this.compileSchema(r[e][i],`${t}/${e}/${i}`))}}validateTypes(e,r,t){if(void 0===r||!Array.isArray(e.validators)||0===e.validators.length)return{valid:!0,errors:[],data:r};let a=[],i=r;for(let o of e.validators){const n=o(e,r,t,this);if(i=n.data,n.valid)return n;a=n.errors}return{valid:0===a.length,errors:a,data:i}}validateKeywords(e,r,t){const a=[];let i=r;if("keywords"in e)for(let r in e.keywords){const o=(0,e.keywords[r])(e,i,t,this);i=o.data,o.valid||a.push(...o.errors)}return{valid:0===a.length,errors:a,data:i}}isSchemaOrKeywordPresent(e){if("type"in e)return!0;for(let r in e)if(this.keywords.has(r))return!0;return!1}isSchemaLike(e){return p(e)&&this.isSchemaOrKeywordPresent(e)}}};"undefined"!=typeof module?module.exports=_:self.SchemaShield=_})();//# sourceMappingURL=index.min.js.map