(()=>{var e,r,t=Object.create,a=Object.defineProperty,o=Object.getOwnPropertyDescriptor,n=Object.getOwnPropertyNames,i=Object.getPrototypeOf,s=Object.prototype.hasOwnProperty,l=(e={"node_modules/is-my-ip-valid/index.js"(e,r){var t=/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,a=/\/\d{1,3}(?=%|$)/,o=/\//,n=/%.*$/,i=/([^0-9a-f:/%])/i,s=/([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/i;r.exports.__all_regexes__=[t,a,o,n,i,s]}},function(){return r||(0,e[n(e)[0]])((r={exports:{}}).exports,r),r.exports}),d=class extends Error{name;pointer;message;value;code;constructor(e,r={pointer:"",value:null,code:""}){super(e),this.name="ValidationError",this.pointer=r.pointer,this.message=e,this.value=r.value,this.code=r.code}};function u(e,r){if(Array.isArray(e)&&Array.isArray(r)){if(e.length!==r.length)return!1;for(let t=0;t<e.length;t++)if(!u(e[t],r[t]))return!1;return!0}if("object"==typeof e&&"object"==typeof r){if(null===e||null===r)return e===r;const t=Object.keys(e);if(t.length!==Object.keys(r).length)return!1;for(const a of t)if(!u(e[a],r[a]))return!1;return!0}return e===r}function c(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)}var p=((e,r,l)=>(l=null!=e?t(i(e)):{},((e,r,t,i)=>{if(r&&"object"==typeof r||"function"==typeof r)for(let l of n(r))s.call(e,l)||l===t||a(e,l,{get:()=>r[l],enumerable:!(i=o(r,l))||i.enumerable});return e})(!r&&e&&e.__esModule?l:a(l,"default",{value:e,enumerable:!0}),e)))(l()),f={"date-time":/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(\.\d+)?(Z|([+-])(\d{2}):(\d{2}))$/,time:/^(\d{2}):(\d{2}):(\d{2})(\.\d+)?(Z|([+-])(\d{2}):(\d{2}))$/,uri:/^[a-zA-Z][a-zA-Z0-9+\-.]*:[^\s]*$/,email:/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,hostname:/^[a-zA-Z0-9][a-zA-Z0-9-]{0,62}(\.[a-zA-Z0-9][a-zA-Z0-9-]{0,62})*[a-zA-Z0-9]$/,date:/^(\d{4})-(\d{2})-(\d{2})$/,"json-pointer":/^\/(?:[^~]|~0|~1)*$/,"relative-json-pointer":/^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/};function v(e){throw new d(`Format "${e}" is not implemented yet. Please open an issue on GitHub.`)}var m={"date-time"(e){const r=e.toUpperCase();if(!f["date-time"].test(r))return!1;const t=new Date(r);return!isNaN(t.getTime())},uri:e=>f.uri.test(e),email(e){if(!f.email.test(e))return!1;const[r,t]=e.split("@");return!(r.length>64||-1!==r.indexOf("..")||"."===r[0]||"."===r[r.length-1])&&!(t.length>255||-1!==t.indexOf("..")||"."===t[0]||"."===t[t.length-1])},ipv4:(0,p.default)({version:4}),ipv6:(0,p.default)({version:6}),hostname:e=>f.hostname.test(e),date:e=>"string"==typeof e&&(!1!==f.date.test(e)&&!isNaN(new Date(e).getTime())),regex(e){try{return new RegExp(e),!0}catch(e){return!1}},"json-pointer":e=>""===e||f["json-pointer"].test(e),"relative-json-pointer":e=>""===e||f["relative-json-pointer"].test(e),time:e=>f.time.test(e),duration:v,"idn-email":v,"idn-hostname":v,uuid:v,"uri-reference":v,iri:v,"iri-reference":v,"uri-template":v},y={object:(e,r,t)=>c(r)?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Data is not an object",{pointer:t,value:r,code:"NOT_AN_OBJECT"})],data:r},array(e,r,t){if(Array.isArray(r))return{valid:!0,errors:[],data:r};if("object"==typeof r&&null!==r&&"length"in r){const e=Object.keys(r);return e.length>0&&("0"!==e[0]||e.length!==r.length)?{valid:!1,errors:[new d("Data is not an array",{pointer:t,value:r,code:"NOT_AN_ARRAY"})],data:r}:{valid:!0,errors:[],data:r}}return{valid:!1,errors:[new d("Data is not an array",{pointer:t,value:r,code:"NOT_AN_ARRAY"})],data:r}},string:(e,r,t)=>"string"==typeof r?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Data is not a string",{pointer:t,value:r,code:"NOT_A_STRING"})],data:r},number:(e,r,t)=>"number"==typeof r?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Data is not a number",{pointer:t,value:r,code:"NOT_A_NUMBER"})],data:r},integer:(e,r,t)=>"number"==typeof r&&Number.isInteger(r)?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Data is not an integer",{pointer:t,value:r,code:"NOT_AN_INTEGER"})],data:r},boolean:(e,r,t)=>"boolean"==typeof r?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Data is not a boolean",{pointer:t,value:r,code:"NOT_A_BOOLEAN"})],data:r},null:(e,r,t)=>null===r?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Data is not null",{pointer:t,value:r,code:"NOT_NULL"})],data:r}},h={...{required(e,r,t){if(!c(r))return{valid:!0,errors:[],data:r};const a=[];for(let o=0;o<e.required.length;o++){const n=e.required[o];r.hasOwnProperty(n)||a.push(new d("Missing required property",{pointer:`${t}/${n}`,value:r,code:"MISSING_REQUIRED_PROPERTY"}))}return{valid:0===a.length,errors:a,data:r}},properties(e,r,t,a){if(!c(r))return{valid:!0,errors:[],data:r};const o=[];let n={...r};for(let i in e.properties){if(!r.hasOwnProperty(i)||void 0===r[i]){c(e.properties[i])&&"default"in e.properties[i]&&(n[i]=e.properties[i].default);continue}if("boolean"==typeof e.properties[i]){!1===e.properties[i]&&o.push(new d("Property is not allowed",{pointer:`${t}/${i}`,value:r[i],code:"PROPERTY_NOT_ALLOWED"}));continue}const{validator:s}=e.properties[i];if(!s)continue;const l=s(e.properties[i],n[i],`${t}/${i}`,a);n[i]=l.data,l.valid||o.push(...l.errors)}return{valid:0===o.length,errors:o,data:n}},maxProperties:(e,r,t)=>!c(r)||Object.keys(r).length<=e.maxProperties?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Object has too many properties",{pointer:t,value:r,code:"OBJECT_TOO_MANY_PROPERTIES"})],data:r},minProperties:(e,r,t)=>!c(r)||Object.keys(r).length>=e.minProperties?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Object has too few properties",{pointer:t,value:r,code:"OBJECT_TOO_FEW_PROPERTIES"})],data:r},additionalProperties(e,r,t,a){if(!c(r))return{valid:!0,errors:[],data:r};const o=[];let n={...r};const i=Object.keys(r);for(const s of i){if(e.properties&&e.properties.hasOwnProperty(s))continue;if(e.patternProperties){let r=!1;for(const t in e.patternProperties)if(new RegExp(t,"u").test(s)){r=!0;break}if(r)continue}if(!1===e.additionalProperties){o.push(new d("Additional property not allowed",{pointer:`${t}/${s}`,value:r,code:"ADDITIONAL_PROPERTY_NOT_ALLOWED"}));continue}const{validator:i}=e.additionalProperties;if(!i)continue;const l=i(e.additionalProperties,n[s],`${t}/${s}`,a);n[s]=l.data,l.valid||o.push(...l.errors)}return{valid:0===o.length,errors:o,data:n}},patternProperties(e,r,t,a){if(!c(r))return{valid:!0,errors:[],data:r};const o=[];let n={...r};const i=Object.keys(e.patternProperties);for(const s of i){const i=new RegExp(s,"u");if("boolean"==typeof e.patternProperties[s]){if(!1===e.patternProperties[s])for(const e in n)i.test(e)&&o.push(new d("Property is not allowed",{pointer:`${t}/${e}`,value:r[e],code:"PROPERTY_NOT_ALLOWED"}));continue}const{validator:l}=e.patternProperties[s];if(!l)continue;const u=Object.keys(n);for(const r of u)if(i.test(r)){const i=l(e.patternProperties[s],n[r],`${t}/${r}`,a);n[r]=i.data,i.valid||o.push(...i.errors)}}return{valid:0===o.length,errors:o,data:n}},propertyNames(e,r,t,a){if(!c(r))return{valid:!0,errors:[],data:r};if("boolean"==typeof e.propertyNames&&!1===e.propertyNames&&Object.keys(r).length>0)return{valid:!1,errors:[new d("Property names are not allowed",{pointer:t,value:r,code:"PROPERTY_NAMES_NOT_ALLOWED"})],data:r};const o=[];let n={...r};const{validator:i}=e.propertyNames;if(!i)return{valid:!0,errors:[],data:r};for(let r in n){const n=i(e.propertyNames,r,t,a);n.valid||o.push(...n.errors)}return{valid:0===o.length,errors:o,data:n}}},...{items(e,r,t,a){if(!Array.isArray(r))return{valid:!0,errors:[],data:r};const o=[],n=[...r],i=e.items,s=Array.isArray(i)?i.length:0,l=r.length;if(Array.isArray(i)){const e=Math.min(s,l);for(let s=0;s<e;s++){if("boolean"==typeof i[s]){!1===i[s]&&void 0!==r[s]&&o.push(new d("Array item is not allowed",{pointer:`${t}/${s}`,value:r[s],code:"ARRAY_ITEM_NOT_ALLOWED"}));continue}const{validator:e}=i[s];if(!e)continue;const l=e(i[s],n[s],`${t}/${s}`,a);n[s]=l.data,l.valid||o.push(...l.errors)}}else if("boolean"==typeof i)!1===i&&l>0&&o.push(new d("Array is not allowed",{pointer:t,value:r,code:"ARRAY_NOT_ALLOWED"}));else{const{validator:e}=i;if(!e)return{valid:!0,errors:[],data:r};for(let r=0;r<l;r++){const s=e(i,n[r],`${t}/${r}`,a);n[r]=s.data,s.valid||o.push(...s.errors)}}return{valid:0===o.length,errors:o,data:n}},minItems:(e,r,t)=>!Array.isArray(r)||r.length>=e.minItems?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Array is too short",{pointer:t,value:r,code:"ARRAY_TOO_SHORT"})],data:r},maxItems:(e,r,t)=>!Array.isArray(r)||r.length<=e.maxItems?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Array is too long",{pointer:t,value:r,code:"ARRAY_TOO_LONG"})],data:r},additionalItems(e,r,t,a){if(!Array.isArray(r)||!e.items||!Array.isArray(e.items))return{valid:!0,errors:[],data:r};if(!1===e.additionalItems)return r.length>e.items.length?{valid:!1,errors:[new d("Array has too many items",{pointer:t,value:r,code:"ARRAY_TOO_MANY_ITEMS"})],data:r}:{valid:!0,errors:[],data:r};const o=[];let n=[...r];if("object"==typeof e.additionalItems)for(let r=e.items.length;r<n.length;r++){const{validator:i}=e.additionalItems,s=i(e.additionalItems,n[r],`${t}/${r}`,a);s.valid||o.push(...s.errors),n[r]=s.data}return{valid:0===o.length,errors:o,data:n}},uniqueItems(e,r,t){if(!Array.isArray(r)||!e.uniqueItems)return{valid:!0,errors:[],data:r};const a=new Map;for(const e of r){let o;if("string"==typeof e)o=`"${e}"`;else if(c(e)){const r=Object.fromEntries(Object.entries(e).sort(([e],[r])=>e.localeCompare(r)));o=JSON.stringify(r)}else o=Array.isArray(e)?JSON.stringify(e):e;if(a.has(o))return{valid:!1,errors:[new d("Array items are not unique",{pointer:t,value:r,code:"ARRAY_ITEMS_NOT_UNIQUE"})],data:r};a.set(o,!0)}return{valid:!0,errors:[],data:r}}},...{minLength:(e,r,t)=>"string"!=typeof r||r.length>=e.minLength?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("String is too short",{pointer:t,value:r,code:"STRING_TOO_SHORT"})],data:r},maxLength:(e,r,t)=>"string"!=typeof r||r.length<=e.maxLength?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("String is too long",{pointer:t,value:r,code:"STRING_TOO_LONG"})],data:r},pattern(e,r,t){if("string"!=typeof r)return{valid:!0,errors:[],data:r};const a=new RegExp(e.pattern,"u");if(a instanceof RegExp==!1)return{valid:!1,errors:[new d("Pattern is not a valid regular expression",{pointer:t,value:r,code:"PATTERN_IS_NOT_REGEXP"})],data:r};const o=a.test(r);return{valid:o,errors:o?[]:[new d("String does not match pattern",{pointer:t,value:r,code:"STRING_DOES_NOT_MATCH_PATTERN"})],data:r}},format(e,r,t,a){if("string"!=typeof r)return{valid:!0,errors:[],data:r};const o=a.formats.get(e.format);if(!o)return{valid:!1,errors:[new d(`Unknown format ${e.format}`,{pointer:t,value:r,code:"UNKNOWN_FORMAT"})],data:r};const n=o(r);return{valid:n,errors:n?[]:[new d(`String does not match format ${e.format}`,{pointer:t,value:r,code:"STRING_DOES_NOT_MATCH_FORMAT"})],data:r}},enum(e,r,t){const a=Array.isArray(r),o="object"==typeof r&&null!==r;for(let t=0;t<e.enum.length;t++){const n=e.enum[t];if(n===r)return{valid:!0,errors:[],data:r};if((a&&Array.isArray(n)||o&&"object"==typeof n&&null!==n)&&u(n,r))return{valid:!0,errors:[],data:r}}return{valid:!1,errors:[new d(`Value must be one of ${e.enum.join(", ")}`,{pointer:t,value:r,code:"VALUE_NOT_IN_ENUM"})],data:r}}},...{minimum(e,r,t,a){if("number"!=typeof r)return{valid:!0,errors:[],data:r};let o=e.minimum;"number"==typeof e.exclusiveMinimum?o=e.exclusiveMinimum+1e-15:!0===e.exclusiveMinimum&&(o+=1e-15);const n=r>=o;return{valid:n,errors:n?[]:[new d("Number is too small",{pointer:t,value:r,code:"NUMBER_TOO_SMALL"})],data:r}},maximum(e,r,t,a){if("number"!=typeof r)return{valid:!0,errors:[],data:r};let o=e.maximum;"number"==typeof e.exclusiveMaximum?o=e.exclusiveMaximum-1e-15:!0===e.exclusiveMaximum&&(o-=1e-15);const n=r<=o;return{valid:n,errors:n?[]:[new d("Number is too big",{pointer:t,value:r,code:"NUMBER_TOO_BIG"})],data:r}},multipleOf(e,r,t){if("number"!=typeof r)return{valid:!0,errors:[],data:r};const a=r/e.multipleOf;if(!isFinite(a))return{valid:!0,errors:[],data:r};const o=function(e,r,t=1e-15){return Math.abs(e-r)<=t*Math.max(Math.abs(e),Math.abs(r))}(a,Math.round(a));return{valid:o,errors:o?[]:[new d("Number is not a multiple of",{pointer:t,value:r,code:"NUMBER_NOT_MULTIPLE_OF"})],data:r}},exclusiveMinimum(e,r,t){if("number"!=typeof r||"number"!=typeof e.exclusiveMinimum||"minimum"in e)return{valid:!0,errors:[],data:r};const a=r>e.exclusiveMinimum+1e-15;return{valid:a,errors:a?[]:[new d("Number is too small",{pointer:t,value:r,code:"NUMBER_TOO_SMALL"})],data:r}},exclusiveMaximum(e,r,t){if("number"!=typeof r||"number"!=typeof e.exclusiveMaximum||"maximum"in e)return{valid:!0,errors:[],data:r};const a=r<e.exclusiveMaximum-1e-15;return{valid:a,errors:a?[]:[new d("Number is too big",{pointer:t,value:r,code:"NUMBER_TOO_BIG"})],data:r}}},...{nullable:(e,r,t)=>e.nullable&&null!==r?{valid:!1,errors:[new d("Value must be null to be empty",{pointer:t,value:r,code:"VALUE_NOT_NULL"})],data:r}:{valid:!0,errors:[],data:r},allOf(e,r,t,a){const o=[];let n=r;for(let i=0;i<e.allOf.length;i++)if(c(e.allOf[i])){const{validator:r}=e.allOf[i];if(!r)continue;const s=r(e.allOf[i],n,t,a);s.valid||o.push(...s.errors),n=s.data}else{if("boolean"==typeof e.allOf[i]){Boolean(r)!==e.allOf[i]&&o.push(new d("Value must match all schemas in allOf",{pointer:t,value:r,code:"VALUE_DOES_NOT_MATCH_ALL_OF"}));continue}r!==e.allOf[i]&&o.push(new d("Value must match all schemas in allOf",{pointer:t,value:r,code:"VALUE_DOES_NOT_MATCH_ALL_OF"}))}return{valid:0===o.length,errors:o,data:n}},anyOf(e,r,t,a){let o=r;for(let n=0;n<e.anyOf.length;n++)if(c(e.anyOf[n])){const{validator:i}=e.anyOf[n];if(!i)return{valid:!0,errors:[],data:r};const s=i(e.anyOf[n],o,t,a);if(o=s.data,s.valid)return{valid:!0,errors:[],data:o}}else{if("boolean"==typeof e.anyOf[n]&&Boolean(r)===e.anyOf[n])return{valid:!0,errors:[],data:o};if(r===e.anyOf[n])return{valid:!0,errors:[],data:o}}return{valid:!1,errors:[new d("Value must match at least one schema in anyOf",{pointer:t,value:r,code:"VALUE_DOES_NOT_MATCH_ANY_OF"})],data:r}},oneOf(e,r,t,a){const o=[];let n=0,i=r;for(let s=0;s<e.oneOf.length;s++)if(c(e.oneOf[s])){const{validator:r}=e.oneOf[s];if(!r){n++;continue}const l=r(e.oneOf[s],i,t,a);l.valid?n++:o.push(...l.errors),i=l.data}else{if("boolean"==typeof e.oneOf[s]){Boolean(r)===e.oneOf[s]&&n++;continue}r===e.oneOf[s]&&n++}return 1===n?{valid:!0,errors:[],data:i}:{valid:!1,errors:[new d("Value must match exactly one schema in oneOf",{pointer:t,value:r,code:"VALUE_DOES_NOT_MATCH_ONE_OF"})],data:i}},dependencies(e,r,t,a){if(!c(r))return{valid:!0,errors:[],data:r};const o=[];let n=r;for(const i in e.dependencies){if(i in r==!1)continue;const s=e.dependencies[i];if(Array.isArray(s)){for(let e=0;e<s.length;e++)s[e]in r||o.push(new d(`Dependency ${s[e]} is missing`,{pointer:t,value:r,code:"DEPENDENCY_MISSING"}));continue}if("boolean"==typeof s){if(s)continue;o.push(new d(`Dependency ${i} is missing`,{pointer:t,value:r,code:"DEPENDENCY_MISSING"}));continue}if("string"==typeof s){if(s in r)continue;o.push(new d(`Dependency ${s} is missing`,{pointer:t,value:r,code:"DEPENDENCY_MISSING"}));continue}const{validator:l}=s;if(!l)continue;const u=l(s,n,t,a);u.valid||o.push(...u.errors),n=u.data}return{valid:0===o.length,errors:o,data:n}},const:(e,r,t)=>r===e.const||c(r)&&c(e.const)&&u(r,e.const)||Array.isArray(r)&&Array.isArray(e.const)&&u(r,e.const)?{valid:!0,errors:[],data:r}:{valid:!1,errors:[new d("Value must be equal to const",{pointer:t,value:r,code:"VALUE_NOT_EQUAL_TO_CONST"})],data:r},contains(e,r,t,a){if(!Array.isArray(r))return{valid:!0,errors:[],data:r};if("boolean"==typeof e.contains){if(e.contains){const e=r.length>0;return{valid:e,errors:e?[]:[new d("Value must contain at least one item",{pointer:t,value:r,code:"VALUE_DOES_NOT_CONTAIN_ITEM"})],data:r}}return{valid:!1,errors:[new d("Value must not contain any items",{pointer:t,value:r,code:"VALUE_CONTAINS_ITEM"})],data:r}}const{validator:o}=e.contains;if(!o)return{valid:!0,errors:[],data:r};for(let n=0;n<r.length;n++){if(o(e.contains,r[n],`${t}/${n}`,a).valid)return{valid:!0,errors:[],data:r}}return{valid:!1,errors:[new d("Value must contain at least one item that matches the contains schema",{pointer:t,value:r,code:"VALUE_DOES_NOT_CONTAIN_MATCHING_ITEM"})],data:r}},if(e,r,t,a){if("then"in e==!1&&"else"in e==!1)return{valid:!0,errors:[],data:r};if("boolean"==typeof e.if){if(e.if){if(e.then){const{validator:o}=e.then;if(o){const n=o(e.then,r,t,a);if(!n.valid)return n}}}else if(e.else){const{validator:o}=e.else;if(o){const n=o(e.else,r,t,a);if(!n.valid)return n}}return{valid:!0,errors:[],data:r}}const{validator:o}=e.if;if(!o)return{valid:!0,errors:[],data:r};if(o(e.if,r,t,a).valid){if(e.then){const{validator:o}=e.then;if(o){const n=o(e.then,r,t,a);if(!n.valid)return n}}}else if(e.else){const{validator:o}=e.else;if(o){const n=o(e.else,r,t,a);if(!n.valid)return n}}return{valid:!0,errors:[],data:r}},not(e,r,t,a){if("boolean"==typeof e.not)return e.not?{valid:!1,errors:[new d("Value must not be valid",{pointer:t,value:r,code:"VALUE_IS_VALID"})],data:r}:{valid:!0,errors:[],data:r};const{validator:o}=e.not;if(!o)return{valid:!1,errors:[new d("Value must not be valid",{pointer:t,value:r,code:"VALUE_IS_VALID"})],data:r};return o(e.not,r,t,a).valid?{valid:!1,errors:[new d("Value must not be valid",{pointer:t,value:r,code:"VALUE_IS_VALID"})],data:r}:{valid:!0,errors:[],data:r}}}},O={SchemaShield:class{types=new Map;formats=new Map;keywords=new Map;constructor(){Object.keys(y).forEach(e=>{this.addType(e,y[e])}),Object.keys(h).forEach(e=>{this.addKeyword(e,h[e])}),Object.keys(m).forEach(e=>{this.addFormat(e,m[e])})}addType(e,r){this.types.set(e,r)}addFormat(e,r){this.formats.set(e,r)}addKeyword(e,r){this.keywords.set(e,r)}compile(e){const r=this.compileSchema(e,"#"),t=e=>r.validator(r,e,"#",this);return t.compiledSchema=r,t}compileSchema(e,r){this.isSchemaLike(e)||(!0===e&&(e={anyOf:[{type:"string"},{type:"number"},{type:"boolean"},{type:"array"},{type:"object"},{type:"null"}]}),!1===e&&(e={oneOf:[]}));const t={...e,pointer:r};if("type"in t){const e=Array.isArray(t.type)?t.type:t.type.split(",").map(e=>e.trim());t.validators=e.map(e=>this.types.get(e)).filter(e=>void 0!==e)}t.validator=(e,r,t)=>{if(void 0===r&&"#"===t)return{valid:!1,errors:[new d("Data is undefined",{pointer:t,value:r,code:"DATA_UNDEFINED"})],data:r};let a=r;const o=this.validateTypes(e,a,t);return!1===o.valid?o:(a=o.data,this.validateKeywords(e,a,t))};for(let a in e)if("type"!==a){if(this.keywords.has(a)){const e=this.keywords.get(a);t.keywords=t.keywords||{},t.keywords[a]=e}this.handleSubSchema(a,e,r,t)}return t}handleSubSchema(e,r,t,a){if(Array.isArray(r[e]))a[e]=r[e].map((r,a)=>this.isSchemaLike(r)?this.compileSchema(r,`${t}/${e}/${a}`):r);else if(c(r[e])){if(this.isSchemaLike(r[e])&&"properties"!==e)return void(a[e]=this.compileSchema(r[e],`${t}/${e}`));for(let o in r[e])this.isSchemaLike(r[e][o])&&(a[e]=a[e]||{},a[e][o]=this.compileSchema(r[e][o],`${t}/${e}/${o}`))}}validateTypes(e,r,t){if(void 0===r||!Array.isArray(e.validators)||0===e.validators.length)return{valid:!0,errors:[],data:r};let a=[],o=r;for(let n of e.validators){const i=n(e,r,t,this);if(o=i.data,i.valid)return i;a=i.errors}return{valid:0===a.length,errors:a,data:o}}validateKeywords(e,r,t){const a=[];let o=r;if("keywords"in e)for(let r in e.keywords){const n=(0,e.keywords[r])(e,o,t,this);o=n.data,n.valid||a.push(...n.errors)}return{valid:0===a.length,errors:a,data:o}}isSchemaOrKeywordPresent(e){if("type"in e)return!0;for(let r in e)if(this.keywords.has(r))return!0;return!1}isSchemaLike(e){return c(e)&&this.isSchemaOrKeywordPresent(e)}}};"undefined"!=typeof module?module.exports=O:self.SchemaShield=O})();//# sourceMappingURL=index.min.js.map