(()=>{var e=class extends Error{message;item;keyword;cause;schemaPath="";instancePath="";data;schema;_getCause(t="#",i="#"){let r=`${t}/${this.keyword}`,a=`${i}`;return void 0!==this.item&&("string"==typeof this.item&&this.item in this.schema&&(r+=`/${this.item}`),a+=`/${this.item}`),this.instancePath=a,this.schemaPath=r,this.cause&&this.cause instanceof e?this.cause._getCause(r,a):this}getCause(){return this._getCause()}_getTree(){const e={message:this.message,keyword:this.keyword,item:this.item,schemaPath:this.schemaPath,instancePath:this.instancePath,data:this.data};return this.cause&&(e.cause=this.cause._getTree()),e}getTree(){return this.getCause(),this._getTree()}getPath(){const e=this.getCause();return{schemaPath:e.schemaPath,instancePath:e.instancePath}}};function t(t,i){const r=new e(`Invalid ${t}`);r.keyword=t,r.schema=i;return s(`defineError_${t}`,(e,t={})=>(r.message=e,r.item=t.item,r.cause=t.cause,r.data=t.data,r))}function i(e,t){if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(!i(e[r],t[r]))return!1;return!0}if("object"==typeof e&&"object"==typeof t){if(null===e||null===t)return e===t;const r=Object.keys(e);if(r.length!==Object.keys(t).length)return!1;for(const a of r)if(!i(e[a],t[a]))return!1;return!0}return e===t}function r(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)}function a(e){if(Array.isArray(e)){const t=[];for(let i=0;i<e.length;i++)t[i]=a(e[i]);return t}if(e&&e.constructor&&"Object"!==e.constructor.name)return e;if(r(e)){const t={...e};for(const i in e)t[i]=a(e[i]);return t}return e}function n(e){return r(e)&&"$validate"in e}function s(e,t){return Object.defineProperty(t,"name",{value:e})}var o={"date-time"(e){const t=e.match(/^(\d{4})-(0[0-9]|1[0-2])-(\d{2})T(0[0-9]|1\d|2[0-3]):([0-5]\d):((?:[0-5]\d|60))(?:.\d+)?(?:([+-])(0[0-9]|1\d|2[0-3]):([0-5]\d)|Z)?$/i);if(!t)return!1;let i=Number(t[3]);if("02"===t[2]&&i>29)return!1;const[,r,a,,n,s,o,l,u,f]=t;let d=Number(r),m=Number(a),c=Number(n),p=Number(s),y=Number(o);if("-"===l||"+"===l){const e=Number(u),t=Number(f);if("-"===l?(c+=e,p+=t):"+"===l&&(c-=e,p-=t),p>59?(c+=1,p-=60):p<0&&(c-=1,p+=60),c>23?(i+=1,c-=24):c<0&&(i-=1,c+=24),i>31?(m+=1,i-=31):i<1&&(m-=1,i+=31),m>12?(d+=1,m-=12):m<1&&(d-=1,m+=12),d<0)return!1}return!(i>(2===m?d%4!=0||d%100==0&&d%400!=0?28:29:[31,,31,30,31,30,31,31,30,31,30,31][m-1]))&&(60!==y||59===p&&23===c)},uri:e=>/^[a-zA-Z][a-zA-Z0-9+\-.]*:[^\s]*$/.test(e),email:e=>/^(?!\.)(?!.*\.$)[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,20}(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]{1,21}){0,2}@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,60}[a-z0-9])?){0,3}$/i.test(e),ipv4:e=>/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])$/.test(e),ipv6(e){if("::"===e)return!0;if(-1===e.indexOf(":")||/(?:\s+|:::+|^\w{5,}|\w{5}$|^:{1}\w|\w:{1}$)/.test(e))return!1;const t=-1!==e.indexOf(".");let i=e;if(t){i=e.split(":");const t=i.pop();if(!/^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])$/.test(t))return!1}const r=-1!==e.indexOf("::"),a=t?i.join(":"):e;if(r)return!(a.split("::").length-1>1)&&(!!/^[0-9a-fA-F:.]*$/.test(a)&&/^(?:(?:(?:[0-9a-fA-F]{1,4}(?::|$)){1,6}))|(?:::(?:[0-9a-fA-F]{1,4})){0,5}$/.test(a));const n=/^(?:(?:[0-9a-fA-F]{1,4}:){7}(?:[0-9a-fA-F]{1,4}|:))$/.test(a),s=/(?:[0-9a-fA-F]{5,}|\D[0-9a-fA-F]{3}:)/.test(a);return t?n||!s:n&&!s},hostname:e=>/^[a-z0-9][a-z0-9-]{0,62}(?:\.[a-z0-9][a-z0-9-]{0,62})*[a-z0-9]$/i.test(e),date:e=>!1!==/^(\d{4})-(\d{2})-(\d{2})$/.test(e)&&!isNaN(new Date(e).getTime()),regex(e){try{return new RegExp(e),!0}catch(e){return!1}},"json-pointer":e=>""===e||/^\/(?:[^~]|~0|~1)*$/.test(e),"relative-json-pointer":e=>""===e||/^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/.test(e),time:e=>/^(\d{2}):(\d{2}):(\d{2})(\.\d+)?(Z|([+-])(\d{2}):(\d{2}))$/.test(e),"uri-reference":e=>!/\\/.test(e)&&/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#((?![^#]*\\)[^#]*))?/i.test(e),"uri-template":e=>/^(?:(?:https?:\/\/[\w.-]+)?\/?)?[\w- ;,.\/?%&=]*(?:\{[\w-]+(?::\d+)?\}[\w- ;,.\/?%&=]*)*\/?$/.test(e),duration:!1,uuid:!1,"idn-email":!1,"idn-hostname":!1,iri:!1,"iri-reference":!1},l={object:e=>r(e),array:e=>!!Array.isArray(e)||"object"==typeof e&&null!==e&&"length"in e&&"0"in e&&Object.keys(e).length-1===e.length,string:e=>"string"==typeof e,number:e=>"number"==typeof e,integer:e=>"number"==typeof e&&e%1==0,boolean:e=>"boolean"==typeof e,null:e=>null===e,timestamp:!1,int8:!1,unit8:!1,int16:!1,unit16:!1,int32:!1,unit32:!1,float32:!1,float64:!1},u={...{required(e,t,i){if(r(t))for(let r=0;r<e.required.length;r++){const a=e.required[r];if(!t.hasOwnProperty(a))return i("Required property is missing",{item:a,data:t[a]})}},properties(e,t,i){if(r(t))for(const a of Object.keys(e.properties))if(t.hasOwnProperty(a)){if("boolean"!=typeof e.properties[a]){if("$validate"in e.properties[a]){const r=e.properties[a].$validate(t[a]);if(r)return i("Property is invalid",{item:a,cause:r,data:t[a]})}}else if(!1===e.properties[a])return i("Property is not allowed",{item:a,data:t[a]})}else{const i=e.properties[a];r(i)&&"default"in i&&(t[a]=i.default)}},values(e,t,i){if(!r(t)||!n(e.values))return;const a=Object.keys(t);for(const r of a){const a=e.values.$validate(t[r]);if(a)return i("Property is invalid",{item:r,cause:a,data:t[r]})}},maxProperties(e,t,i){if(r(t)&&!(Object.keys(t).length<=e.maxProperties))return i("Too many properties",{data:t})},minProperties(e,t,i){if(r(t)&&!(Object.keys(t).length>=e.minProperties))return i("Too few properties",{data:t})},additionalProperties(e,t,i){if(!r(t))return;const a=Object.keys(t),s=n(e.additionalProperties);for(const r of a)if(!e.properties||!e.properties.hasOwnProperty(r)){if(e.patternProperties){let t=!1;for(const i in e.patternProperties)if(new RegExp(i,"u").test(r)){t=!0;break}if(t)continue}if(!1===e.additionalProperties)return i("Additional properties are not allowed",{item:r,data:t[r]});if(s){const a=e.additionalProperties.$validate(t[r]);if(a)return i("Additional properties are invalid",{item:r,cause:a,data:t[r]})}}},patternProperties(e,t,i){if(!r(t))return;const a=Object.keys(e.patternProperties);for(const r of a){const a=new RegExp(r,"u");if("boolean"==typeof e.patternProperties[r]){if(!1===e.patternProperties[r])for(const e in t)if(a.test(e))return i("Property is not allowed",{item:e,data:t[e]});continue}const n=Object.keys(t);for(const s of n)if(a.test(s)&&"$validate"in e.patternProperties[r]){const a=e.patternProperties[r].$validate(t[s]);if(a)return i("Property is invalid",{item:s,cause:a,data:t[s]})}}},propertyNames(e,t,i){if(r(t)){if("boolean"==typeof e.propertyNames&&!1===e.propertyNames&&Object.keys(t).length>0)return i("Properties are not allowed",{data:t});if(n(e.propertyNames))for(let r in t){const a=e.propertyNames.$validate(r);if(a)return i("Property name is invalid",{item:r,cause:a,data:t[r]})}}},dependencies(e,t,i){if(r(t))for(const r in e.dependencies){if(r in t==!1)continue;const a=e.dependencies[r];if(Array.isArray(a)){for(let e=0;e<a.length;e++)if(!(a[e]in t))return i("Dependency is not satisfied",{item:e,data:a[e]});continue}if("boolean"==typeof a){if(a)continue;return i("Dependency is not satisfied",{data:a})}if("string"==typeof a){if(a in t)continue;return i("Dependency is not satisfied",{data:a})}const n=a.$validate(t);if(n)return i("Dependency is not satisfied",{cause:n,data:t})}},then:!1,else:!1,default:!1,$ref:!1,definitions:!1,$id:!1,$schema:!1,title:!1,description:!1,$comment:!1,examples:!1,contentMediaType:!1,contentEncoding:!1,discriminator:!1,nullable:!1},...{items(e,t,i){if(!Array.isArray(t))return;const r=e.items,a=t.length;if("boolean"==typeof r)return!1===r&&a>0?i("Array items are not allowed",{data:t}):void 0;if(Array.isArray(r)){const e=r.length,s=Math.min(e,a);for(let e=0;e<s;e++){const a=r[e];if("boolean"!=typeof a){if(n(a)){const r=a.$validate(t[e]);if(r)return i("Array item is invalid",{item:e,cause:r,data:t[e]})}}else if(!1===a&&void 0!==t[e])return i("Array item is not allowed",{item:e,data:t[e]})}}else if(n(r))for(let e=0;e<a;e++){const a=r.$validate(t[e]);if(a)return i("Array item is invalid",{item:e,cause:a,data:t[e]})}},elements(e,t,i){if(Array.isArray(t)&&n(e.elements))for(let r=0;r<t.length;r++){const a=e.elements.$validate(t[r]);if(a)return i("Array item is invalid",{item:r,cause:a,data:t[r]})}},minItems(e,t,i){if(Array.isArray(t)&&!(t.length>=e.minItems))return i("Array is too short",{data:t})},maxItems(e,t,i){if(Array.isArray(t)&&!(t.length<=e.maxItems))return i("Array is too long",{data:t})},additionalItems(e,t,i){if(e.items&&!r(e.items)){if(!1===e.additionalItems)return t.length>e.items.length?i("Array is too long",{data:t}):void 0;if(r(e.additionalItems)){if(n(e.additionalItems)){for(let r=e.items.length;r<t.length;r++){const a=e.additionalItems.$validate(t[r]);if(a)return i("Array item is invalid",{item:r,cause:a,data:t[r]})}return}}else;}},uniqueItems(e,t,i){if(!Array.isArray(t)||!e.uniqueItems)return;const a=new Set;for(const e of t){let t;if(t="string"==typeof e?`s:${e}`:r(e)?`o:${JSON.stringify(Object.fromEntries(Object.entries(e).sort(([e],[t])=>e.localeCompare(t))))}`:Array.isArray(e)?JSON.stringify(e):String(e),a.has(t))return i("Array items are not unique",{data:e});a.add(t)}},contains(e,t,i){if(Array.isArray(t)){if("boolean"==typeof e.contains)return e.contains?0===t.length?i("Array must contain at least one item",{data:t}):void 0:i("Array must not contain any items",{data:t});for(let i=0;i<t.length;i++){if(!e.contains.$validate(t[i]))return}return i("Array must contain at least one item",{data:t})}}},...{minLength(e,t,i){if(!("string"!=typeof t||t.length>=e.minLength))return i("Value is shorter than the minimum length",{data:t})},maxLength(e,t,i){if(!("string"!=typeof t||t.length<=e.maxLength))return i("Value is longer than the maximum length",{data:t})},pattern(e,t,i){if("string"!=typeof t)return;const r=new RegExp(e.pattern,"u");return r instanceof RegExp==!1?i("Invalid regular expression",{data:t}):r.test(t)?void 0:i("Value does not match the pattern",{data:t})},format(e,t,i,r){if("string"!=typeof t)return;const a=r.getFormat(e.format);return a&&!a(t)?i("Value does not match the format",{data:t}):void 0}},...{minimum(e,t,i,r){if("number"!=typeof t)return;let a=e.minimum;return"number"==typeof e.exclusiveMinimum?a=e.exclusiveMinimum+1e-15:!0===e.exclusiveMinimum&&(a+=1e-15),t<a?i("Value is less than the minimum",{data:t}):void 0},maximum(e,t,i,r){if("number"!=typeof t)return;let a=e.maximum;return"number"==typeof e.exclusiveMaximum?a=e.exclusiveMaximum-1e-15:!0===e.exclusiveMaximum&&(a-=1e-15),t>a?i("Value is greater than the maximum",{data:t}):void 0},multipleOf(e,t,i,r){if("number"!=typeof t)return;const a=t/e.multipleOf;return isFinite(a)?function(e,t,i=1e-15){return Math.abs(e-t)<=i*Math.max(Math.abs(e),Math.abs(t))}(a,Math.round(a))?void 0:i("Value is not a multiple of the multipleOf",{data:t}):void 0},exclusiveMinimum(e,t,i,r){if("number"==typeof t&&"number"==typeof e.exclusiveMinimum&&!("minimum"in e))return t<=e.exclusiveMinimum+1e-15?i("Value is less than or equal to the exclusiveMinimum"):void 0},exclusiveMaximum(e,t,i,r){if("number"==typeof t&&"number"==typeof e.exclusiveMaximum&&!("maximum"in e))return t>=e.exclusiveMaximum?i("Value is greater than or equal to the exclusiveMaximum",{data:t}):void 0}},...{enum(e,t,r){const a=Array.isArray(t),n="object"==typeof t&&null!==t;for(let r=0;r<e.enum.length;r++){const s=e.enum[r];if(s===t)return;if((a&&Array.isArray(s)||n&&"object"==typeof s&&null!==s)&&i(s,t))return}return r("Value is not one of the allowed values",{data:t})},allOf(e,t,i){for(let a=0;a<e.allOf.length;a++)if(r(e.allOf[a])){if("$validate"in e.allOf[a]){const r=e.allOf[a].$validate(t);if(r)return i("Value is not valid",{cause:r,data:t})}}else if("boolean"!=typeof e.allOf[a]){if(t!==e.allOf[a])return i("Value is not valid",{data:t})}else if(Boolean(t)!==e.allOf[a])return i("Value is not valid",{data:t})},anyOf(e,t,i){for(let i=0;i<e.anyOf.length;i++){if(r(e.anyOf[i])){if("$validate"in e.anyOf[i]){if(!e.anyOf[i].$validate(t))return;continue}return}if("boolean"==typeof e.anyOf[i]&&Boolean(t)===e.anyOf[i])return;if(t===e.anyOf[i])return}return i("Value is not valid",{data:t})},oneOf(e,t,i){let a=0;for(let i=0;i<e.oneOf.length;i++)if(r(e.oneOf[i])){if("$validate"in e.oneOf[i]){e.oneOf[i].$validate(t)||a++;continue}a++}else"boolean"!=typeof e.oneOf[i]?t===e.oneOf[i]&&a++:Boolean(t)===e.oneOf[i]&&a++;if(1!==a)return i("Value is not valid",{data:t})},const(e,t,a){if(!(t===e.const||r(t)&&r(e.const)&&i(t,e.const)||Array.isArray(t)&&Array.isArray(e.const)&&i(t,e.const)))return a("Value is not valid",{data:t})},if(e,t,i){if("then"in e==!1&&"else"in e==!1)return;if("boolean"==typeof e.if){if(e.if){if(n(e.then))return e.then.$validate(t)}else if(n(e.else))return e.else.$validate(t);return}if(!n(e.if))return;return e.if.$validate(t)?n(e.else)?e.else.$validate(t):void 0:n(e.then)?e.then.$validate(t):void 0},not(e,t,i){if("boolean"==typeof e.not)return e.not?i("Value is not valid",{data:t}):void 0;if(r(e.not)){if("$validate"in e.not){const r=e.not.$validate(t);return r?void 0:i("Value is not valid",{cause:r,data:t})}return i("Value is not valid",{data:t})}return i("Value is not valid",{data:t})}}},f={SchemaShield:class{types={};formats={};keywords={};immutable=!1;constructor({immutable:e=!1}={}){this.immutable=e;for(const[e,t]of Object.entries(l))t&&this.addType(e,t);for(const[e,t]of Object.entries(u))this.addKeyword(e,t);for(const[e,t]of Object.entries(o))t&&this.addFormat(e,t)}addType(t,i,r=!1){if(this.types[t]&&!r)throw new e(`Type "${t}" already exists`);this.types[t]=i}getType(e){return this.types[e]}addFormat(t,i,r=!1){if(this.formats[t]&&!r)throw new e(`Format "${t}" already exists`);this.formats[t]=i}getFormat(e){return this.formats[e]}addKeyword(t,i,r=!1){if(this.keywords[t]&&!r)throw new e(`Keyword "${t}" already exists`);this.keywords[t]=i}getKeyword(e){return this.keywords[e]}compile(t){const i=this.compileSchema(t);if(!i.$validate){if(!1===this.isSchemaLike(t))throw new e("Invalid schema");i.$validate=s("any",()=>{})}const r=e=>{const t=this.immutable?a(e):e,r=i.$validate(t);return{data:t,error:r||null,valid:!r}};return r.compiledSchema=i,r}compileSchema(e){r(e)||(e=!0===e?{anyOf:[{}]}:!1===e?{oneOf:[]}:{oneOf:[e]});const i=a(e),n=t("type",e),o=[];let l="";if("type"in e){const t=Array.isArray(e.type)?e.type:e.type.split(",").map(e=>e.trim());for(const e of t){const t=this.getType(e);t&&(o.push(t),l+=(l?"_OR_":"")+t.name)}const r=o.length;if(0===r)throw n("Invalid type for schema",{data:e.type});if(1===r){const e=o[0];i.$validate=s(l,t=>{if(!e(t))return n("Invalid type",{data:t})})}else r>1&&(i.$validate=s(l,e=>{for(let t=0;t<r;t++)if(o[t](e))return;return n("Invalid type",{data:e})}))}for(const a of Object.keys(e)){if("type"===a){i.type=e.type;continue}const n=this.getKeyword(a);if(n){const r=t(a,e[a]);if(i.$validate){const e=i.$validate;l+=`_AND_${n.name}`,i.$validate=s(l,t=>{const a=e(t);return a||n(i,t,r,this)})}else l=n.name,i.$validate=s(l,e=>n(i,e,r,this))}if(r(e[a])){if("properties"===a){for(const t of Object.keys(e[a]))i[a][t]=this.compileSchema(e[a][t]);continue}i[a]=this.compileSchema(e[a])}else Array.isArray(e[a])?i[a]=e[a].map((e,t)=>this.isSchemaLike(e)?this.compileSchema(e):e):i[a]=e[a]}return i}isSchemaLike(e){if(r(e)){if("type"in e)return!0;for(let t in e)if(t in this.keywords)return!0}return!1}}};"undefined"!=typeof module?module.exports=f:self.SchemaShield=f})();//# sourceMappingURL=index.min.js.map