(()=>{var e=class extends Error{name;pointer;message;value;code;constructor(e,r={pointer:"",value:null,code:""}){super(e),this.name="ValidationError",this.pointer=r.pointer,this.message=e,this.value=r.value,this.code=r.code}};function r(e,t){if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let a=0;a<e.length;a++)if(!r(e[a],t[a]))return!1;return!0}if("object"==typeof e&&"object"==typeof t){if(null===e||null===t)return e===t;const a=Object.keys(e);if(a.length!==Object.keys(t).length)return!1;for(const o of a)if(!r(e[o],t[o]))return!1;return!0}return e===t}function t(e){return"object"==typeof e&&null!==e&&!Array.isArray(e)}var a={"date-time":/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[+-]\d{2}:\d{2})$/,uri:/^[a-zA-Z][a-zA-Z0-9+\-.]*:[^\s]*$/,email:/^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,ipv4:/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,ipv6:/^(?:(?:[0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|(?=(?:[0-9a-fA-F]{0,4}:){0,7}[0-9a-fA-F]{0,4}(?![:.\w]))(([0-9a-fA-F]{1,4}:){1,7}|:)((:[0-9a-fA-F]{1,4}){1,7}|:))$/,hostname:/^[a-zA-Z0-9][a-zA-Z0-9-]{0,62}(\.[a-zA-Z0-9][a-zA-Z0-9-]{0,62})*$/};function o(r){throw new e(`Format "${r}" is not implemented yet. Please open an issue on GitHub.`)}var i={"date-time":e=>a["date-time"].test(e),uri:e=>a.uri.test(e),email:e=>a.email.test(e),ipv4:e=>a.ipv4.test(e),ipv6:e=>a.ipv6.test(e),hostname:e=>a.hostname.test(e),time:o,date:o,duration:o,"idn-email":o,"idn-hostname":o,uuid:o,"uri-reference":o,iri:o,"iri-reference":o,"uri-template":o,"json-pointer":o,"relative-json-pointer":o,regex:o},n={object:(r,t,a)=>"object"!=typeof t||null===t||Array.isArray(t)?{valid:!1,errors:[new e("Data is not an object",{pointer:a,value:t,code:"NOT_AN_OBJECT"})],data:t}:{valid:!0,errors:[],data:t},array(r,t,a){if(Array.isArray(t))return{valid:!0,errors:[],data:t};if("object"==typeof t&&null!==t&&"length"in t){const r=Object.keys(t);return r.length>0&&("0"!==r[0]||r.length!==t.length)?{valid:!1,errors:[new e("Data is not an array",{pointer:a,value:t,code:"NOT_AN_ARRAY"})],data:t}:{valid:!0,errors:[],data:t}}return{valid:!1,errors:[new e("Data is not an array",{pointer:a,value:t,code:"NOT_AN_ARRAY"})],data:t}},string:(r,t,a)=>"string"==typeof t?{valid:!0,errors:[],data:t}:{valid:!1,errors:[new e("Data is not a string",{pointer:a,value:t,code:"NOT_A_STRING"})],data:t},number:(r,t,a)=>"number"==typeof t?{valid:!0,errors:[],data:t}:{valid:!1,errors:[new e("Data is not a number",{pointer:a,value:t,code:"NOT_A_NUMBER"})],data:t},integer:(r,t,a)=>"number"==typeof t&&Number.isInteger(t)?{valid:!0,errors:[],data:t}:{valid:!1,errors:[new e("Data is not an integer",{pointer:a,value:t,code:"NOT_AN_INTEGER"})],data:t},boolean:(r,t,a)=>"boolean"==typeof t?{valid:!0,errors:[],data:t}:{valid:!1,errors:[new e("Data is not a boolean",{pointer:a,value:t,code:"NOT_A_BOOLEAN"})],data:t},null:(r,t,a)=>null===t?{valid:!0,errors:[],data:t}:{valid:!1,errors:[new e("Data is not null",{pointer:a,value:t,code:"NOT_NULL"})],data:t}},s={...{required(r,a,o){if(!t(a))return{valid:!0,errors:[],data:a};const i=[];for(let t=0;t<r.required.length;t++){const n=r.required[t];a.hasOwnProperty(n)||i.push(new e("Missing required property",{pointer:`${o}/${n}`,value:a,code:"MISSING_REQUIRED_PROPERTY"}))}return{valid:0===i.length,errors:i,data:a}},properties(r,a,o,i){if(!t(a))return{valid:!0,errors:[],data:a};const n=[];let s={...a};for(let l in r.properties){if(!a.hasOwnProperty(l)||void 0===a[l]){t(r.properties[l])&&"default"in r.properties[l]&&(s[l]=r.properties[l].default);continue}if("boolean"==typeof r.properties[l]){!1===r.properties[l]&&n.push(new e("Property is not allowed",{pointer:`${o}/${l}`,value:a[l],code:"PROPERTY_NOT_ALLOWED"}));continue}const{validator:d}=r.properties[l];if(!d)continue;const u=d(r.properties[l],s[l],`${o}/${l}`,i);s[l]=u.data,u.valid||n.push(...u.errors)}return{valid:0===n.length,errors:n,data:s}},maxProperties:(r,a,o)=>!t(a)||Object.keys(a).length<=r.maxProperties?{valid:!0,errors:[],data:a}:{valid:!1,errors:[new e("Object has too many properties",{pointer:o,value:a,code:"OBJECT_TOO_MANY_PROPERTIES"})],data:a},minProperties:(r,a,o)=>!t(a)||Object.keys(a).length>=r.minProperties?{valid:!0,errors:[],data:a}:{valid:!1,errors:[new e("Object has too few properties",{pointer:o,value:a,code:"OBJECT_TOO_FEW_PROPERTIES"})],data:a},additionalProperties(r,a,o,i){if(!t(a))return{valid:!0,errors:[],data:a};const n=[];let s={...a};for(let t in a){if(r.properties&&r.properties.hasOwnProperty(t))continue;if(r.patternProperties){let e=!1;for(let a in r.patternProperties)if(new RegExp(a).test(t)){e=!0;break}if(e)continue}if(!1===r.additionalProperties){n.push(new e("Additional property not allowed",{pointer:`${o}/${t}`,value:a,code:"ADDITIONAL_PROPERTY_NOT_ALLOWED"}));continue}const{validator:l}=r.additionalProperties;if(!l)continue;const d=l(r.additionalProperties,s[t],`${o}/${t}`,i);s[t]=d.data,d.valid||n.push(...d.errors)}return{valid:0===n.length,errors:n,data:s}},patternProperties(r,a,o,i){if(!t(a))return{valid:!0,errors:[],data:a};const n=[];let s={...a};for(let t in r.patternProperties){if("boolean"==typeof r.patternProperties[t]){if(!1===r.patternProperties[t])for(let r in s)new RegExp(t).test(r)&&n.push(new e("Property is not allowed",{pointer:`${o}/${r}`,value:a[r],code:"PROPERTY_NOT_ALLOWED"}));continue}const{validator:l}=r.patternProperties[t];if(l)for(let e in s)if(new RegExp(t).test(e)){const a=l(r.patternProperties[t],s[e],`${o}/${e}`,i);s[e]=a.data,a.valid||n.push(...a.errors)}}return{valid:0===n.length,errors:n,data:s}}},...{items(r,t,a,o){if(!Array.isArray(t))return{valid:!0,errors:[],data:t};const i=[];let n=[...t];if(Array.isArray(r.items))for(let s=0;s<r.items.length;s++){if("boolean"==typeof r.items[s]){!1===r.items[s]&&void 0!==t[s]&&i.push(new e("Array item is not allowed",{pointer:`${a}/${s}`,value:t[s],code:"ARRAY_ITEM_NOT_ALLOWED"}));continue}const{validator:l}=r.items[s];if(!l)continue;const d=l(r.items[s],n[s],`${a}/${s}`,o);n[s]=d.data,d.valid||i.push(...d.errors)}else if("boolean"==typeof r.items)!1===r.items&&t.length>0&&i.push(new e("Array is not allowed",{pointer:a,value:t,code:"ARRAY_NOT_ALLOWED"}));else{const{validator:e}=r.items;if(!e)return{valid:!0,errors:[],data:t};for(let t=0;t<n.length;t++){const s=e(r.items,n[t],`${a}/${t}`,o);n[t]=s.data,s.valid||i.push(...s.errors)}}return{valid:0===i.length,errors:i,data:n}},minItems:(r,t,a)=>!Array.isArray(t)||t.length>=r.minItems?{valid:!0,errors:[],data:t}:{valid:!1,errors:[new e("Array is too short",{pointer:a,value:t,code:"ARRAY_TOO_SHORT"})],data:t},maxItems:(r,t,a)=>!Array.isArray(t)||t.length<=r.maxItems?{valid:!0,errors:[],data:t}:{valid:!1,errors:[new e("Array is too long",{pointer:a,value:t,code:"ARRAY_TOO_LONG"})],data:t},additionalItems(r,t,a,o){if(!Array.isArray(t)||!r.items||!Array.isArray(r.items))return{valid:!0,errors:[],data:t};if(!1===r.additionalItems)return t.length>r.items.length?{valid:!1,errors:[new e("Array has too many items",{pointer:a,value:t,code:"ARRAY_TOO_MANY_ITEMS"})],data:t}:{valid:!0,errors:[],data:t};const i=[];let n=[...t];if("object"==typeof r.additionalItems)for(let e=r.items.length;e<n.length;e++){const{validator:t}=r.additionalItems,s=t(r.additionalItems,n[e],`${a}/${e}`,o);s.valid||i.push(...s.errors),n[e]=s.data}return{valid:0===i.length,errors:i,data:n}},uniqueItems(r,a,o){if(!Array.isArray(a)||!r.uniqueItems)return{valid:!0,errors:[],data:a};const i=new Set;for(const r of a){let n=r;if("string"==typeof r)n=`"${r}"`;else if(t(r)){const e=Object.keys(r).sort(),t={};for(let a=0;a<e.length;a++)t[e[a]]=r[e[a]];n=JSON.stringify(t)}else Array.isArray(r)&&(n=JSON.stringify(r));if(i.has(n))return{valid:!1,errors:[new e("Array items are not unique",{pointer:o,value:a,code:"ARRAY_ITEMS_NOT_UNIQUE"})],data:a};i.add(n)}return{valid:!0,errors:[],data:a}}},...{minLength:(r,t,a)=>"string"!=typeof t||t.length>=r.minLength?{valid:!0,errors:[],data:t}:{valid:!1,errors:[new e("String is too short",{pointer:a,value:t,code:"STRING_TOO_SHORT"})],data:t},maxLength:(r,t,a)=>"string"!=typeof t||t.length<=r.maxLength?{valid:!0,errors:[],data:t}:{valid:!1,errors:[new e("String is too long",{pointer:a,value:t,code:"STRING_TOO_LONG"})],data:t},pattern(r,t,a){if("string"!=typeof t)return{valid:!0,errors:[],data:t};const o="string"==typeof r.pattern?new RegExp(r.pattern):r.pattern;if(o instanceof RegExp==!1)return{valid:!1,errors:[new e("Pattern is not a valid regular expression",{pointer:a,value:t,code:"PATTERN_IS_NOT_REGEXP"})],data:t};const i=o.test(t);return{valid:i,errors:i?[]:[new e("String does not match pattern",{pointer:a,value:t,code:"STRING_DOES_NOT_MATCH_PATTERN"})],data:t}},format(r,t,a,o){if("string"!=typeof t)return{valid:!0,errors:[],data:t};const i=o.formats.get(r.format);if(!i)return{valid:!1,errors:[new e(`Unknown format ${r.format}`,{pointer:a,value:t,code:"UNKNOWN_FORMAT"})],data:t};const n=i(t);return{valid:n,errors:n?[]:[new e(`String does not match format ${r.format}`,{pointer:a,value:t,code:"STRING_DOES_NOT_MATCH_FORMAT"})],data:t}},enum(t,a,o){for(let e=0;e<t.enum.length;e++)if(t.enum[e]===a)return{valid:!0,errors:[],data:a};if(Array.isArray(a))for(let e=0;e<t.enum.length;e++)if(Array.isArray(t.enum[e])&&r(t.enum[e],a))return{valid:!0,errors:[],data:a};if("object"==typeof a&&null!==a)for(let e=0;e<t.enum.length;e++)if("object"==typeof t.enum[e]&&null!==t.enum[e]&&r(t.enum[e],a))return{valid:!0,errors:[],data:a};return{valid:!1,errors:[new e(`Value must be one of ${t.enum.join(", ")}`,{pointer:o,value:a,code:"VALUE_NOT_IN_ENUM"})],data:a}}},...{minimum(r,t,a){if("number"!=typeof t)return{valid:!0,errors:[],data:t};const o=t>=(r.exclusiveMinimum?r.minimum+1e-15:r.minimum);return{valid:o,errors:o?[]:[new e("Number is too small",{pointer:a,value:t,code:"NUMBER_TOO_SMALL"})],data:t}},maximum(r,t,a){if("number"!=typeof t)return{valid:!0,errors:[],data:t};const o=t<=(r.exclusiveMaximum?r.maximum-1e-15:r.maximum);return{valid:o,errors:o?[]:[new e("Number is too large",{pointer:a,value:t,code:"NUMBER_TOO_LARGE"})],data:t}},multipleOf(r,t,a){if("number"!=typeof t)return{valid:!0,errors:[],data:t};const o=t/r.multipleOf,i=Math.abs(o-Math.round(o))<1e-15;return{valid:i,errors:i?[]:[new e("Number is not a multiple of",{pointer:a,value:t,code:"NUMBER_NOT_MULTIPLE_OF"})],data:t}}},...{nullable:(r,t,a)=>r.nullable&&null!==t?{valid:!1,errors:[new e("Value must be null to be empty",{pointer:a,value:t,code:"VALUE_NOT_NULL"})],data:t}:{valid:!0,errors:[],data:t},oneOf(r,a,o,i){const n=[];let s=0,l=a;for(let e=0;e<r.oneOf.length;e++)if(t(r.oneOf[e])){const{validator:t}=r.oneOf[e];if(!t){s++;continue}const a=t(r.oneOf[e],l,o,i);a.valid?s++:n.push(...a.errors),l=a.data}else{if("boolean"==typeof r.oneOf[e]){Boolean(a)===r.oneOf[e]&&s++;continue}a===r.oneOf[e]&&s++}return 1===s?{valid:!0,errors:[],data:l}:{valid:!1,errors:[new e("Value must match exactly one schema in oneOf",{pointer:o,value:a,code:"VALUE_DOES_NOT_MATCH_ONE_OF"})],data:l}},allOf(r,a,o,i){const n=[];let s=a;for(let l=0;l<r.allOf.length;l++)if(t(r.allOf[l])){const{validator:e}=r.allOf[l];if(!e)continue;const t=e(r.allOf[l],s,o,i);t.valid||n.push(...t.errors),s=t.data}else{if("boolean"==typeof r.allOf[l]){Boolean(a)!==r.allOf[l]&&n.push(new e("Value must match all schemas in allOf",{pointer:o,value:a,code:"VALUE_DOES_NOT_MATCH_ALL_OF"}));continue}a!==r.allOf[l]&&n.push(new e("Value must match all schemas in allOf",{pointer:o,value:a,code:"VALUE_DOES_NOT_MATCH_ALL_OF"}))}return{valid:0===n.length,errors:n,data:s}},anyOf(r,a,o,i){let n=a;for(let e=0;e<r.anyOf.length;e++)if(t(r.anyOf[e])){const{validator:t}=r.anyOf[e];if(!t)return{valid:!0,errors:[],data:a};const s=t(r.anyOf[e],n,o,i);if(n=s.data,s.valid)return{valid:!0,errors:[],data:n}}else{if("boolean"==typeof r.anyOf[e]&&Boolean(a)===r.anyOf[e])return{valid:!0,errors:[],data:n};if(a===r.anyOf[e])return{valid:!0,errors:[],data:n}}return{valid:!1,errors:[new e("Value must match at least one schema in anyOf",{pointer:o,value:a,code:"VALUE_DOES_NOT_MATCH_ANY_OF"})],data:a}},dependencies(r,a,o,i){if(!t(a))return{valid:!0,errors:[],data:a};const n=[];let s=a;for(const t in r.dependencies){if(t in a==!1)continue;const l=r.dependencies[t];if(Array.isArray(l)){for(let r=0;r<l.length;r++)l[r]in a||n.push(new e(`Dependency ${l[r]} is missing`,{pointer:o,value:a,code:"DEPENDENCY_MISSING"}));continue}if("boolean"==typeof l){if(l)continue;n.push(new e(`Dependency ${t} is missing`,{pointer:o,value:a,code:"DEPENDENCY_MISSING"}));continue}if("string"==typeof l){if(l in a)continue;n.push(new e(`Dependency ${l} is missing`,{pointer:o,value:a,code:"DEPENDENCY_MISSING"}));continue}const{validator:d}=l;if(!d)continue;const u=d(l,s,o,i);u.valid||n.push(...u.errors),s=u.data}return{valid:0===n.length,errors:n,data:s}}}},l={SchemaShield:class{types=new Map;formats=new Map;keywords=new Map;constructor(){for(const e in n)this.addType(e,n[e]);for(const e in s)this.addKeyword(e,s[e]);for(const e in i)this.addFormat(e,i[e])}addType(e,r){this.types.set(e,r)}addFormat(e,r){this.formats.set(e,r)}addKeyword(e,r){this.keywords.set(e,r)}compile(e){const r=this.compileSchema(e,"#"),t=this;function a(e){return r.validator(r,e,"#",t)}return a.compiledSchema=r,a}compileSchema(r,a){if("object"!=typeof r||null===r)throw new e("Schema is not an object",{pointer:a,value:r,code:"SCHEMA_NOT_OBJECT"});const o={...r,pointer:a};if("type"in o){const e=Array.isArray(o.type)?o.type:o.type.split(",").map(e=>e.trim());o.validators=e.filter(e=>this.types.has(e)).map(e=>this.types.get(e))}o.validator=(r,t,a)=>{if(void 0===t&&"#"===a)return{valid:!1,errors:[new e("Data is undefined",{pointer:a,value:t,code:"DATA_UNDEFINED"})],data:t};let o=t;const i=this.validateTypes(r,o,a);return!1===i.valid?i:(o=i.data,this.validateKeywords(r,o,a))};for(let e in r)if("type"!==e){if(this.keywords.has(e)){const r=this.keywords.get(e);o.keywords=o.keywords||{},o.keywords[e]=r}Array.isArray(r[e])?this.handleArraySchema(e,r,a,o):t(r[e])&&this.handleObjectSchema(e,r,a,o)}return o}handleArraySchema(e,r,t,a){a[e]=r[e].map((r,a)=>{if("object"==typeof r&&null!==r){if("type"in r)return this.compileSchema(r,`${t}/${e}/${a}`);for(let o in r)if(this.keywords.has(o))return this.compileSchema(r,`${t}/${e}/${a}`)}return r})}handleObjectSchema(e,r,t,a){if("type"in r[e])a[e]=this.compileSchema(r[e],`${t}/${e}`);else for(let o in r[e])if(a[e]=a[e]||{},this.keywords.has(o))a[e][o]=this.compileSchema(r[e][o],`${t}/${o}`);else if("object"==typeof r[e][o]){if("type"in r[e][o]){a[e][o]=this.compileSchema(r[e][o],`${t}/${e}/${o}`);continue}for(let i in r[e][o])this.keywords.has(i)&&(a[e][o]=this.compileSchema(r[e][o],`${t}/${e}/${o}`))}}validateTypes(e,r,t){if(void 0===r||!Array.isArray(e.validators)||0===e.validators.length)return{valid:!0,errors:[],data:r};let a=[],o=r;for(let i of e.validators){const n=i(e,r,t,this);if(o=n.data,n.valid)return n;a=n.errors}return{valid:0===a.length,errors:a,data:o}}validateKeywords(e,r,t){const a=[];let o=r;if("keywords"in e)for(let r in e.keywords){const i=(0,e.keywords[r])(e,o,t,this);o=i.data,i.valid||a.push(...i.errors)}return{valid:0===a.length,errors:a,data:o}}}};"undefined"!=typeof module?module.exports=l:self.SchemaShield=l})();//# sourceMappingURL=index.min.js.map